{"version":3,"file":"pspdfkit-lib/chunk-server-84ffe2fdfac63b32.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/ServerBackend/authentication.ts","webpack://PSPDFKit/./src/lib/ServerBackend/hostedAuthentication.ts","webpack://PSPDFKit/./src/utils/load.ts","webpack://PSPDFKit/./src/lib/ServerBackend/ServerBackendState.ts","webpack://PSPDFKit/./src/lib/requests/types/XHRImageRequest.ts","webpack://PSPDFKit/./src/lib/ServerBackend/ServerBackend.ts","webpack://PSPDFKit/./src/models/InstantSettings.ts"],"sourcesContent":["import { PSPDFKitError } from '@pspdfkit/shared'\nimport { getVersionHeader } from '@/utils/environment'\nimport { ILicenseFeature } from '@/enums/LicenseFeature'\n\nimport type { SignaturesInfoJSON } from '@/core/CoreTypes'\nimport type { ISignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\n\nexport type AuthResponse = {\n  imageToken: string\n  token: string\n  permissions: Array<string>\n  features: Array<ILicenseFeature>\n  signatureFeatureAvailability: ISignatureFeatureAvailability\n  hasPassword: boolean\n  minSearchQueryLength: number\n  layerHandle: string\n  allowedTileScales: 'all' | Array<number>\n  digitalSignatures: SignaturesInfoJSON\n  defaultGroup: string | undefined\n  creatorName: string | undefined\n  collaborationPermissions?: Record<string, any>\n}\n\n/**\n * Calls the `/auth` endpoint and generates the tokens.\n */\nexport async function authenticate(\n  documentURL: string,\n  authPayload: {\n    jwt: string\n  },\n  password?: string | null,\n): Promise<AuthResponse> {\n  const res = await fetch(`${documentURL}/auth`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': getVersionHeader(),\n    },\n    body: JSON.stringify({\n      jwt: authPayload.jwt,\n      // IE11 does not send `Origin` headers for some requests, since it has a different\n      // understanding of the origin spec. To still be able to verify the origin in the IE11 case,\n      // we add that information as payload manually.\n      // There were some problems with `window.location.origin` in IE11 on Win10 [1], that's why\n      // we use `window.location.href` instead.\n      // [1]: https://goo.gl/5D5mNX\n      origin: window.location.href,\n      password: password,\n    }),\n    credentials: 'include',\n  })\n\n  if (res.ok) {\n    return res.json()\n  } else {\n    return res.text().then(message => {\n      if (message === 'INVALID_PASSWORD') {\n        throw new PSPDFKitError(message)\n      } else {\n        throw new PSPDFKitError(\n          `An error occurred while connecting to PSPDFKit Server: ${message || res.statusText}`,\n        )\n      }\n    })\n  }\n}\n","export type HostedDocumentAuthResponse = {\n  jwt: string\n  serverId: string\n  serverUrl: string\n}\n\n/**\n * Calls the `/auth` endpoint of the Hosted API.\n */\nexport async function authenticateHostedDocument(\n  hostedBaseUrl: string,\n  accessToken: string,\n): Promise<HostedDocumentAuthResponse> {\n  const res = await fetch(`${hostedBaseUrl}i/documents/auth`, {\n    method: 'POST',\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': 'application/json',\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': `cloud-protocol=${PSPDFKIT_DEFINES.HOSTED_CLOUD_PROTOCOL}, server-protocol=${PSPDFKIT_DEFINES.SERVER_PROTOCOL}, client=${PSPDFKIT_DEFINES.VERSION}, client-git=${PSPDFKIT_DEFINES.REVISION}`,\n    },\n    body: JSON.stringify({\n      accessToken,\n    }),\n  })\n\n  if (res.ok) {\n    return res.json()\n  } else {\n    throw new Error(`An error occurred while connecting to PSPDFKit API: ${await res.text()}`)\n  }\n}\n","import { PSPDFKitError } from '@pspdfkit/shared'\nimport { invariant } from '@pspdfkit/shared'\nimport { Base64 } from 'js-base64'\n\n/**\n * This function can be used to validate a JWT. Will throw a PSPDFKitError if\n * the token is invalid.\n * Can also be used to log deprecation warnings.\n */\nexport function validateJWT(jwt: string): void {\n  const JWT_INVALID = `The supplied JWT is invalid. Please refer to our guides on how to set up authentication:\n  https://pspdfkit.com/guides/web/current/server-backed/client-authentication/`\n  const DOCUMENT_ID_NOT_STRING = `The supplied JWT is invalid. The field 'document_id' has to be a string value.\n  Please refer to our guides for further information: https://pspdfkit.com/guides/web/current/server-backed/client-authentication/`\n\n  // Our dashboard uses internal API to authenticate the request. In this case,\n  // the `jwt` is not a valid JWT but another JSON.\n  // We will bypass the validation in this case.\n  if (jwt.indexOf('{\"internal\":') !== -1) {\n    return\n  }\n\n  // We require a JWT to be a string with two dots\n  invariant(typeof jwt === 'string' && jwt.split('.').length === 3, JWT_INVALID)\n\n  // We parse the user data section of the JWT.\n  let userContent\n\n  try {\n    const json = Base64.decode(jwt.split('.')[1])\n\n    userContent = JSON.parse(json)\n  } catch (e) {\n    throw new PSPDFKitError(JWT_INVALID)\n  }\n\n  invariant(typeof userContent.document_id === 'string', DOCUMENT_ID_NOT_STRING)\n}\n\nexport function validateDocumentAccessToken(accessToken: string): void {\n  // noinspection SuspiciousTypeOfGuard\n  if (typeof accessToken !== 'string') {\n    throw new PSPDFKitError('`accessToken` must be of type string.')\n  }\n}\n","import * as Immutable from 'immutable'\nimport { List } from 'immutable'\nimport BackendPermissions from '@/models/BackendPermissions'\nimport {\n  ISignatureFeatureAvailability,\n  SignatureFeatureAvailability,\n} from '@/enums/SignatureFeatureAvailability'\nimport type { SignaturesInfo } from '@/models/digital-signatures/SignaturesInfo'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport { ILicenseFeature } from '@/enums/LicenseFeature'\n\ninterface IServerBackendState {\n  authPayload:\n    | {\n        jwt: string\n      }\n    | {\n        accessToken: string\n      }\n    | null\n  serverUrl: string | null\n  hostedBaseUrl: string | null\n  documentId: string | null\n  backendPermissions: BackendPermissions | null\n  documentURL: string | null\n  imageToken: string | null\n  token: string | null\n  instantSettings: InstantSettings | null\n  features: List<string>\n  signatureFeatureAvailability: ISignatureFeatureAvailability\n  isFormsEnabled: boolean\n  documentHandle: string | null\n  isDocumentHandleOutdated: boolean\n  digitalSignatures: SignaturesInfo | null\n  defaultGroup: string | null | undefined\n  hasCollaborationPermissions: boolean\n  forceLegacySignaturesFeature: boolean\n  minSearchQueryLength: number\n}\n\nexport default class ServerBackendState extends Immutable.Record<IServerBackendState>({\n  authPayload: null,\n  serverUrl: null,\n  hostedBaseUrl: null,\n  documentId: null,\n  backendPermissions: null,\n  documentURL: null,\n  imageToken: null,\n  instantSettings: null,\n  token: null,\n  features: List(),\n  signatureFeatureAvailability: SignatureFeatureAvailability.NONE,\n  isFormsEnabled: true,\n  minSearchQueryLength: 1,\n  documentHandle: null,\n  isDocumentHandleOutdated: false,\n  digitalSignatures: null,\n  defaultGroup: undefined,\n  hasCollaborationPermissions: false,\n  forceLegacySignaturesFeature: false,\n}) {\n  /**\n   * The auth payload used to create the PSPDFKit for Web instance. This is most likely an object\n   * with a key `jwt` that contains the `jwt`.\n   * We also use a special internal authentication token for the PSPDFKit Server dashboard, this\n   * also creates an object here with the key `jwt` but the value is no valid JWT!\n   * Hosted viewer uses a separate `accessToken` to authenticate with the hosted frontend.\n   */\n  override authPayload:\n    | {\n        jwt: string\n      }\n    | {\n        accessToken: string\n      }\n\n  /**\n   * URL to the PSPDFKit Server, e.g: `https://pspdfkit.example.com/`\n   */\n  override serverUrl: string\n\n  /**\n   * URL of the hosted frontend, e.g: `https://api.pspdfkit.com/`\n   */\n  override hostedBaseUrl: string\n\n  /**\n   * The identifier of the document for PSPDFKit Server\n   */\n  override documentId: string\n\n  /**\n   * Defines if the user is allowed to edit annotations or download the document\n   */\n  override backendPermissions: BackendPermissions\n\n  /**\n   * URL to the document, e.g.: `https://pspdfkit.example.com/d/foobar`\n   */\n  override documentURL: string\n\n  /**\n   * This token is used to retrieve images from the Server.\n   */\n  override imageToken: string\n\n  /**\n   * The write token generated by PSPDFKit Server. This is used to authenticate all non image\n   * loading requests.\n   */\n  override token: string\n\n  /**\n   * Holds settings for the instant provider. When present, InstantProvider is used to\n   * communicate with the Server.\n   */\n  override instantSettings: InstantSettings\n\n  /**\n   * PSPDFKit license features, used to detect which features can be used.\n   */\n  override features: List<ILicenseFeature>\n\n  /**\n   * Determines which variant of signatures UI is shown\n   */\n  override signatureFeatureAvailability: ISignatureFeatureAvailability\n\n  /**\n   * Scans the Configuration and the returned features to see if forms shall be implemented. This is\n   * necessary since we initialize the RESTProvider before we can process this information in\n   * other parts of the app.\n   *\n   * FIXME: Find a way to get the actual licenses when initializing RESTProvider so that we don't\n   * have to maintain a separate implementation of form related feature tests.\n   */\n  override isFormsEnabled: boolean\n\n  /**\n   * ID string corresponding to the current document. This field is updated when operations\n   * are applied on the document with the new document SHA256 hash.\n   */\n  override documentHandle: string\n\n  /**\n   * Set when the document has been modified by an external client, thereby modifying the document handle.\n   * When set, the backend should authenticate again and load the modified document with the new `documentHandle`.\n   */\n  override isDocumentHandleOutdated: boolean\n\n  /**\n   * List of digital signatures present in the document.\n   */\n  override digitalSignatures: SignaturesInfo\n\n  /**\n   * Set the default group to use when records are created through the UI\n   */\n  override defaultGroup: string | null | undefined\n\n  /**\n   * Whether Collaboration Permissions are enabled or not\n   */\n  override hasCollaborationPermissions: boolean\n\n  /**\n   * Marks if even though Electronic Signatures licensed for the current user,\n   * the legacy signature mode should be used instead.\n   */\n  override forceLegacySignaturesFeature: boolean\n}\n","import { Request } from './Request'\nimport { requestIsSuccess } from '../../../utils/http'\nimport { webp } from '../../../utils/features'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport ImageHandle from '../../handles/ImageHandle'\nimport { getVersionHeader } from '@/utils/environment'\n\nconst GENERIC_RENDER_ERROR = 'The image can not be rendered because of an unknown error.'\n\nexport default class XHRImageRequest implements Request {\n  identifier: string\n  token: string\n  url: string\n  payload: any\n  httpRequest?: XMLHttpRequest\n  doNotRequestWebP: boolean\n\n  constructor({\n    identifier,\n    url,\n    token,\n    payload,\n    doNotRequestWebP = false,\n  }: {\n    identifier: string\n    url: string\n    token: string\n    payload?: any\n    doNotRequestWebP?: boolean\n  }) {\n    this.identifier = identifier\n    this.url = url\n    this.token = token\n    this.payload = payload\n    this.doNotRequestWebP = doNotRequestWebP\n  }\n\n  abort(): void {\n    this.httpRequest && this.httpRequest.abort()\n  }\n\n  request(): Promise<\n    | ImageHandle\n    | {\n        attachmentsNotFound: Array<string>\n      }\n  > {\n    return new Promise((resolve, reject) => {\n      const httpRequest = new XMLHttpRequest()\n\n      this.httpRequest = httpRequest\n      httpRequest.open(this.payload ? 'POST' : 'GET', this.url, true)\n      httpRequest.setRequestHeader('X-PSPDFKit-Image-Token', this.token)\n      httpRequest.setRequestHeader('PSPDFKit-Platform', 'web')\n      httpRequest.setRequestHeader('PSPDFKit-Version', getVersionHeader())\n\n      if (webp && !this.doNotRequestWebP) {\n        httpRequest.setRequestHeader('Accept', 'image/webp,*/*')\n      }\n\n      httpRequest.responseType = 'blob'\n\n      // We need to use the spec conform `onreadystatechange` since `onload` and `onerror` behaves\n      // differently in our test environment\n      // @TODO inspect what's causing the context of the arrow function to change\n      httpRequest.onreadystatechange = (async () => {\n        // request finished and response is ready\n        if (httpRequest.readyState !== 4) {\n          return\n        }\n\n        // response.type can include charset info, so we only check it begins with application/json\n        if (httpRequest.response && httpRequest.response.type.startsWith('application/json')) {\n          // We have to read the blob here using a FileReader since we configure the http request as\n          // a blob one.\n          const fileReader = new FileReader()\n\n          fileReader.onload = event => {\n            const response = JSON.parse(event.target?.result as string)\n\n            if (response.attachments_not_found) {\n              resolve({\n                attachmentsNotFound: response.attachments_not_found,\n              })\n            } else if (response.error) {\n              reject(\n                new PSPDFKitError(\n                  `The server could not render the requested image (${response.error})`,\n                ),\n              )\n            } else {\n              reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n            }\n          }\n\n          fileReader.onerror = () => reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n\n          fileReader.readAsText(httpRequest.response)\n\n          return\n        }\n\n        if (!requestIsSuccess(httpRequest.status)) {\n          reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n\n          return\n        }\n\n        const blob = httpRequest.response\n        const objectUrl = URL.createObjectURL(blob)\n        const img = new Image()\n\n        img.onerror = () => reject(new PSPDFKitError(GENERIC_RENDER_ERROR))\n\n        img.src = objectUrl\n\n        const imagePromise = // Browsers supporting HTMLImageElement.decode()\n          /* eslint-disable compat/compat */\n          typeof img.decode === 'function'\n            ? /* eslint-enable compat/compat */\n              img.decode() // Browsers not supporting HTMLImageElement.decode() (IE11)\n            : // Since the new image takes a few ms to be decoded and displayed,\n              // we delay resolving with the image.\n              new Promise(resolve => setTimeout(resolve, 200))\n\n        await imagePromise\n        resolve(new ImageHandle(img, () => URL.revokeObjectURL(objectUrl)))\n      }).bind(this)\n\n      httpRequest.send(this.payload)\n    })\n  }\n}\n","import { authenticate } from './authentication'\nimport { authenticateHostedDocument } from './hostedAuthentication'\nimport BackendPermissions from '@/models/BackendPermissions'\nimport WidgetAnnotation from '@/models/annotations/WidgetAnnotation'\nimport { fromJSON as documentOutlineFromJSON } from '../serializers/OutlineElementSerializer'\nimport { getBaseUrl, getVersionHeader } from '@/utils/environment'\nimport { isCacheableAnnotationAPStream, isModifiableAnnotation } from '@/utils/annotation'\nimport { jsonToTextLines } from '@/utils/textLines'\nimport { List } from 'immutable'\nimport { MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER, MAX_WEBP_DIMENSION } from '@/constants/config'\nimport { parseJsonSearchResults } from '@/utils/search'\nimport { PSPDFKitError, warn, isPlainObject } from '@pspdfkit/shared'\nimport { rectToJSON } from '../serializers/rect'\nimport {\n  serializeAnnotation,\n  serializeFormFieldValue,\n  serializeFormField,\n  deserializeSignaturesInfo,\n} from '../serializers/utils'\nimport { validateDocumentAccessToken, validateJWT } from '@/utils/load'\nimport JSONRequest from '../requests/types/JSONRequest'\nimport RequestQueue from '../requests/RequestQueue'\nimport ServerBackendState from './ServerBackendState'\nimport XHRImageRequest from '../requests/types/XHRImageRequest'\nimport { ulid } from 'ulid'\nimport { addBlobToWeakMap } from '@/utils/documentOperations'\nimport { defaultInstantSettings } from '@/models/InstantSettings'\nimport RedactionAnnotationSerializer from '../serializers/RedactionAnnotationSerializer'\nimport { SearchType } from '@/enums/SearchType'\nimport { SharedBackend } from '../SharedBackend'\nimport { SignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\nimport { invariant } from '@pspdfkit/shared'\nimport { EmbeddedFile } from '@/models/EmbeddedFile'\nimport { fromJSON } from '@/lib/serializers/EmbeddedFileSerializer'\nimport { imageHandleFromBlob } from '@/utils/dom'\nimport { supportsFormDataInResponse } from '@/utils/features'\nimport { formFieldValueFromFormField } from '@/utils/forms'\nimport { LicenseFeature } from '@/enums/LicenseFeature'\nimport { validateHostedBaseUrl } from '@/utils/http'\n\nimport type { DiscardablePromise } from '@/utils/promise'\nimport type { FormFieldValueJSON } from '@/models/form-fields/FormFieldValue'\nimport type { ISearchType } from '@/enums/SearchType'\nimport type { IFunction } from '@/typings/utils'\nimport type { ISearchPattern } from '@/enums/SearchPattern'\nimport type { Size, Rect } from '@/models'\nimport type { Map } from 'immutable'\nimport type FormFieldValue from '@/models/form-fields/FormFieldValue'\nimport type ImageHandle from '../handles/ImageHandle'\nimport type { Annotation, Attachment } from '@/models'\nimport type {\n  DocumentResponse,\n  TextResponse,\n  BackendType,\n  LoadResponse,\n  ExportPDFFlags,\n  GetPDFURLFlags,\n  GeneratePDFObjectURLFlags,\n  LoadOptions,\n  FormResponse,\n} from '@/typings/backend'\nimport type { FormField } from '@/models'\nimport type { ActionChange } from '@/models/actions/Action'\nimport type { DocumentOperationJSON } from '@/models/DocumentOperation'\nimport type { InstantJSON } from '../InstantJSON'\nimport type { ServerConfiguration } from '@/Configuration'\nimport type OutlineElement from '@/models/OutlineElement'\nimport type SearchResult from '@/models/search/SearchResult'\nimport type { TwoStepSignatureCallback } from '@/models/digital-signatures/TwoStepSignatureCallback'\nimport type { SignaturesInfo } from '@/models/digital-signatures/SignaturesInfo'\nimport type { SignaturePreparationData } from '@/models/digital-signatures/SignaturePreparationData'\nimport type { SigningServiceData } from '@/models/digital-signatures/SigningServiceData'\nimport type { RESTProvider } from '../RESTProvider/RESTProvider'\nimport type { InstantProvider } from '../InstantProvider/InstantProvider'\nimport type { SignatureInfo } from '@/models/digital-signatures/SignatureInfo'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport type { RedactionAnnotationPreset } from '@/models/RedactionAnnotationPreset'\nimport type { ReadStateProviderCallbacks } from '../ReadStateProvider'\n\n/**\nThis type can be used to control rendering in relation to print.\n\nWhen printing, annotation's `noView` and `noPrint` flags have to be honoured\naccording to the PDF spec:\n\n- An annotation with the noView flag will not be rendered in the UI but may be printable.\n- An annotation with the noPrint flag will not be printed.\n\nFrom: https://pspdfkit.com/guides/web/current/annotations/annotation-flags/\n */\ntype RenderForPrinting = boolean\n\nexport default class ServerBackend extends SharedBackend {\n  provider: RESTProvider | InstantProvider\n  _state: ServerBackendState\n  _requestQueue: RequestQueue\n  _password: string | null | undefined = null\n  _refreshSignaturesInfoPromise: Promise<void> | null | undefined\n  type: BackendType = 'SERVER'\n\n  constructor(configuration: ServerConfiguration, _window: Window = window) {\n    super()\n\n    // Validate authPayload is an object\n    if (!(typeof configuration.authPayload === 'object')) {\n      throw new PSPDFKitError(\n        \"authPayload must be an object that contains the `jwt`. For example: `authPayload: { jwt: 'xxx.xxx.xxx'}`\",\n      )\n    }\n\n    const accessToken = configuration.authPayload?.accessToken\n\n    let serverUrl: string | null = null\n    let documentUrl: string | null = null\n    let hostedBaseUrl: string | null = null\n\n    if (!accessToken) {\n      serverUrl = resolveServerUrl(configuration, _window)\n\n      // Validate document ID\n      if (typeof configuration.documentId !== 'string') {\n        throw new PSPDFKitError('`documentId` must be of type string.')\n      }\n\n      documentUrl = `${serverUrl}i/d/${configuration.documentId}`\n\n      // Validate authPayload\n      // noinspection SuspiciousTypeOfGuard\n      if (\n        !(\n          typeof configuration.authPayload === 'object' &&\n          'jwt' in configuration.authPayload &&\n          typeof configuration.authPayload.jwt === 'string'\n        )\n      ) {\n        throw new PSPDFKitError(\n          \"authPayload must be an object that contains the `jwt`. For example: `authPayload: { jwt: 'xxx.xxx.xxx'}`\",\n        )\n      }\n\n      validateJWT(configuration.authPayload.jwt)\n    } else {\n      hostedBaseUrl = configuration.hostedBaseUrl || 'https://api.pspdfkit.com/'\n      validateHostedBaseUrl(hostedBaseUrl)\n\n      validateDocumentAccessToken(accessToken)\n    }\n\n    validateInstantSetting(configuration.instant)\n\n    let instantSettings: InstantSettings | null | undefined = null\n\n    if (configuration.instant) {\n      if (isPlainObject(configuration.instant)) {\n        const settings = configuration.instant\n\n        instantSettings = {\n          clientsPresenceEnabled: settings.clientsPresenceEnabled !== false,\n          listenToServerChangesEnabled: settings.listenToServerChangesEnabled !== false,\n        }\n      } else {\n        instantSettings = defaultInstantSettings\n      }\n    }\n\n    this._requestQueue = new RequestQueue(MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER)\n\n    const forceLegacySignaturesFeature = configuration.electronicSignatures\n      ? Boolean(configuration.electronicSignatures.forceLegacySignaturesFeature)\n      : false\n\n    this._state = new ServerBackendState({\n      serverUrl,\n      hostedBaseUrl: hostedBaseUrl,\n      documentId: configuration.documentId,\n      instantSettings: instantSettings,\n      documentURL: documentUrl,\n      authPayload: configuration.authPayload,\n      isFormsEnabled: !configuration.disableForms,\n      forceLegacySignaturesFeature,\n    })\n\n    if (configuration['trustedCAsCallback']) {\n      // TODO: Add link to guide article on Server\n      warn(\n        'PSPDFKit.Configuration#trustedCAsCallback is only used on Standalone deployments. On a Server-backed deployment, please follow the instructions at https://pspdfkit.com/guides/web',\n      )\n    }\n  }\n\n  isUsingInstantProvider(): boolean {\n    return this._state.instantSettings != null\n  }\n\n  hasClientsPresence() {\n    const instantSettings = this._state.instantSettings\n\n    return instantSettings != null && instantSettings.clientsPresenceEnabled !== false\n  }\n\n  async load(options: LoadOptions = {}): Promise<LoadResponse> {\n    await this.tryAuthenticateHostedViewer()\n\n    const {\n      imageToken,\n      token,\n      permissions,\n      features,\n      signatureFeatureAvailability,\n      hasPassword,\n      minSearchQueryLength,\n      layerHandle,\n      allowedTileScales,\n      digitalSignatures,\n      defaultGroup,\n      collaborationPermissions,\n      creatorName,\n    } = await authenticate(\n      `${this._state.serverUrl}i/d/${this._state.documentId}`,\n      this._state.authPayload as { jwt: string },\n      options.password,\n    )\n\n    // Keep for reloading after applying operations\n    this._password = options.password\n\n    // check for Instant feature enabled in license if configured for Instant\n    if (this._state.instantSettings && !features.includes(LicenseFeature.INSTANT)) {\n      throw new PSPDFKitError(`Instant feature is not enabled on this server. Please set \\`instant\\` to \\`false\\`.\n\nFor more information about PSPDFKit Instant please visit:\nhttps://pspdfkit.com/guides/web/current/instant/overview/`)\n    }\n\n    const finalSignatureFeatureAvailability =\n      signatureFeatureAvailability === SignatureFeatureAvailability.ELECTRONIC_SIGNATURES &&\n      features.includes(LicenseFeature.WEB_ANNOTATION_EDITING) &&\n      this._state.forceLegacySignaturesFeature\n        ? SignatureFeatureAvailability.LEGACY_SIGNATURES\n        : signatureFeatureAvailability\n\n    this._state = this._state.withMutations(state => {\n      return state\n        .set('imageToken', imageToken)\n        .set('token', token)\n        .set('features', List(features))\n        .set('signatureFeatureAvailability', finalSignatureFeatureAvailability)\n        .set(\n          'backendPermissions',\n          new BackendPermissions({\n            readOnly: permissions.indexOf('write') === -1,\n            downloadingAllowed: permissions.indexOf('download') >= 0,\n          }),\n        )\n        .set(\n          'documentURL',\n          `${this._state.serverUrl}i/d/${this._state.documentId}/h/${layerHandle}`,\n        )\n        .set('documentHandle', layerHandle)\n        .set('isDocumentHandleOutdated', false)\n        .set('digitalSignatures', deserializeSignaturesInfo(digitalSignatures))\n    })\n\n    if (!!collaborationPermissions && !this._state.instantSettings) {\n      throw new PSPDFKitError(\n        'Collaboration Permissions is not supported when `instant` is disabled. Please make sure `configuration#instant` is set to `true`.',\n      )\n    }\n\n    this._state = this._state.withMutations(state => {\n      state.defaultGroup = defaultGroup\n      state.hasCollaborationPermissions = Boolean(collaborationPermissions)\n    })\n\n    if (this.provider) {\n      this.provider.destroy()\n    }\n\n    this.provider = await this._initProvider()\n    this._state.instantSettings &&\n      this.provider.setDocumentHandleConflictCallback(this.handleDocumentHandleConflict)\n\n    return {\n      features: this._state.features,\n      signatureFeatureAvailability: this._state.signatureFeatureAvailability,\n      hasPassword,\n      minSearchQueryLength,\n      allowedTileScales,\n      creatorName,\n      defaultGroup,\n    }\n  }\n\n  private async tryAuthenticateHostedViewer() {\n    if ('accessToken' in this._state.authPayload) {\n      const { hostedBaseUrl } = this._state\n      const accessToken = this._state.authPayload.accessToken\n\n      const { serverUrl, serverId, jwt } = await authenticateHostedDocument(\n        hostedBaseUrl,\n        accessToken,\n      )\n\n      this._state = this._state.withMutations(state => {\n        state\n          .set('serverUrl', serverUrl)\n          .set('documentId', serverId)\n          .set('documentURL', `${serverUrl}i/d/${serverId}`)\n          .set('authPayload', { jwt })\n      })\n    }\n  }\n\n  async _initProvider(): Promise<RESTProvider | InstantProvider> {\n    if (this._state.instantSettings) {\n      const documentURL = `${this._state.serverUrl}i/d/${this._state.documentId}/h/${this._state.documentHandle}`\n      const { InstantProvider } = await import(\n        /* webpackChunkName: \"server-instant\" */\n        '../InstantProvider/InstantProvider'\n      )\n\n      return new InstantProvider(\n        `${this._state.serverUrl}i/d/${this._state.documentId}`,\n        documentURL,\n        {\n          auth_token: this._state.token,\n        },\n        this._state.instantSettings,\n      )\n    } else {\n      const isFormsEnabled =\n        this._state.isFormsEnabled && this._state.features.includes(LicenseFeature.FORMS)\n\n      const { RESTProvider } = await import(\n        /* webpackChunkName: \"server-rest\" */\n        '../RESTProvider/RESTProvider'\n      )\n\n      return new RESTProvider(\n        this._state.documentURL,\n        {\n          token: this._state.token,\n        },\n        {\n          isFormsEnabled,\n        },\n      )\n    }\n  }\n\n  destroy(): void {\n    this._destroyProvider()\n\n    this._requestQueue && this._requestQueue.destroy()\n  }\n\n  documentInfo(): Promise<DocumentResponse> {\n    return this._fetch(`${this._state.documentURL}/document.json`)\n      .then(res => res.json())\n      .then(payload => payload.data)\n  }\n\n  getFormJSON(): Promise<FormResponse> {\n    return this._fetch(`${this._state.documentURL}/form.json`).then(res => {\n      if (res.status === 403) {\n        return {\n          v: 1,\n          type: 'pspdfkit/form',\n          annotations: [],\n          fields: [],\n        }\n      } else {\n        return res.json().then(json => {\n          const formResponse: FormResponse = json.data\n\n          return formResponse\n        })\n      }\n    })\n  }\n\n  async evalFormValuesActions() {\n    throw new Error('not implemented')\n  }\n\n  async evalScript() {\n    throw new Error('not implemented')\n  }\n\n  async setFormJSONUpdateBatchMode() {\n    throw new Error('not implemented')\n  }\n\n  permissions(): Promise<BackendPermissions> {\n    return Promise.resolve(this._state.backendPermissions)\n  }\n\n  getDefaultGroup(): string | null | undefined {\n    return this._state.defaultGroup\n  }\n\n  isCollaborationPermissionsEnabled() {\n    return this._state.hasCollaborationPermissions\n  }\n\n  textForPageIndex(pageIndex: number): {\n    promise: Promise<TextResponse>\n    cancel: IFunction\n  } {\n    const pageTextRequestURL = `${this._state.documentURL}/page-${pageIndex}-text`\n    const jsonRequestPromise = new (this._getJSONRequestHandler())(\n      pageTextRequestURL,\n      this._state.token,\n    )\n\n    const request = this._requestQueue.enqueue(jsonRequestPromise, true)\n\n    const jsonRequestQueuePromise = request.promise.then(json => jsonToTextLines(json, pageIndex))\n\n    return {\n      promise: jsonRequestQueuePromise,\n      cancel: () => {\n        request.cancel()\n      },\n    }\n  }\n\n  getTextFromRects(pageIndex: number, rects: List<Rect>): Promise<string> {\n    const rectsParam = encodeURIComponent(JSON.stringify(rects.map(rectToJSON).toArray()))\n\n    return this._fetch(\n      `${this._state.documentURL}/page-${pageIndex}-highlighted?rects=${rectsParam}`,\n    )\n      .then(res => res.json())\n      .then(response => response.text)\n  }\n\n  _getJSONRequestHandler() {\n    return JSONRequest\n  }\n\n  renderTile(\n    pageIndex: number,\n    pageSize: Size,\n    tileRect: Rect,\n    renderForPrinting: RenderForPrinting,\n    contentState?: {\n      annotations: List<Annotation>\n      formFieldValues: List<FormFieldValue>\n      attachments: Map<string, Attachment>\n      formFields: List<FormField>\n      signatures?: SignatureInfo[]\n    } | null,\n  ): {\n    promise: Promise<ImageHandle>\n    cancel: IFunction\n  } {\n    if (this._state.isDocumentHandleOutdated) {\n      return {\n        promise: new Promise(() => {}),\n        cancel: () => {},\n      }\n    }\n\n    const imageTileURL = `${this._state.documentURL}/page-${pageIndex}-dimensions-${\n      pageSize.width\n    }-${pageSize.height}-tile-${tileRect.left}-${tileRect.top}-${tileRect.width}-${\n      tileRect.height\n    }${renderForPrinting ? '-print' : ''}`\n    const hasPriority = pageSize.width === tileRect.width && pageSize.height === tileRect.height\n    const doNotRequestWebP =\n      tileRect.width > MAX_WEBP_DIMENSION || tileRect.height > MAX_WEBP_DIMENSION\n    let resolvePromise,\n      rejectPromise,\n      isCanceled = false,\n      hasRetried = false,\n      // eslint-disable-next-line prefer-const\n      requestPromises: any = [],\n      // eslint-disable-next-line prefer-const\n      requestImages: any[] = []\n\n    const promise = new Promise<ImageHandle>((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    const requestTile = (includeAttachmentIds: Array<string> = []) => {\n      let imageRequestPromise\n\n      if (contentState) {\n        const formData = new FormData()\n\n        formData.append(\n          'data',\n          JSON.stringify({\n            annotations: contentState.annotations\n              .filter(isModifiableAnnotation)\n              .map(serializeAnnotation)\n              .toJS()\n              .map(content => ({\n                content,\n              })),\n            formFieldValues: contentState.formFieldValues.map(serializeFormFieldValue).toJS(),\n            formFields: contentState.formFields.map(serializeFormField).toJS(),\n            signatures: contentState.signatures || [],\n          }),\n        )\n\n        if (includeAttachmentIds.length > 0) {\n          includeAttachmentIds.forEach(id => {\n            const attachment = contentState.attachments.get(id)\n\n            invariant(attachment && attachment.data, 'Attachment data could not be found.')\n            formData.append(id, attachment.data)\n          })\n        }\n\n        imageRequestPromise = new XHRImageRequest({\n          identifier: imageTileURL,\n          url: imageTileURL,\n          token: this._state.imageToken,\n          payload: formData,\n          doNotRequestWebP,\n        })\n      } else {\n        imageRequestPromise = new XHRImageRequest({\n          identifier: imageTileURL,\n          url: imageTileURL,\n          token: this._state.imageToken,\n          doNotRequestWebP,\n        })\n      }\n\n      requestImages.push(imageRequestPromise)\n\n      const imageRequest = this._requestQueue.enqueue(imageRequestPromise, hasPriority)\n\n      imageRequest.promise\n        .then(tile => {\n          if (isCanceled) {\n            return\n          }\n\n          if (tile.attachmentsNotFound && !hasRetried) {\n            hasRetried = true\n            requestTile(tile.attachmentsNotFound)\n\n            return\n          }\n\n          if (tile.attachmentsNotFound) {\n            rejectPromise(new PSPDFKitError('Attachment could not be found.'))\n\n            return\n          }\n\n          resolvePromise(tile)\n        })\n        .catch(error => {\n          if (isCanceled) {\n            return\n          }\n\n          rejectPromise(error)\n        })\n      requestPromises.push(imageRequest)\n    }\n\n    requestTile()\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n        requestImages.forEach(request => {\n          if (request.abort && typeof request.abort === 'function') request.abort()\n        })\n        requestPromises.forEach(request => {\n          request.cancel()\n        })\n      },\n    }\n  }\n\n  /**\n   * Common method for renderAnnotation and renderDetachedAnnotation.\n   */\n  _requestRenderAnnotation = (\n    annotation: Annotation,\n    formFieldValue: FormFieldValue | null | undefined,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n    detached?: boolean,\n  ) => {\n    const renderAnnotationURL = `${this._state.documentURL}/render_annotation`\n    const requestQueueId = `render-annotation-${detached ? ulid() : annotation.id}`\n    const annotationJSON = JSON.stringify({\n      data: serializeAnnotation(annotation),\n      width: width,\n      height: height,\n      detached: detached || undefined,\n      formFieldValue: formFieldValue ? serializeFormFieldValue(formFieldValue) : undefined,\n    })\n    let resolvePromise,\n      rejectPromise,\n      isCanceled = false,\n      // eslint-disable-next-line prefer-const\n      hasRetried = false,\n      // eslint-disable-next-line prefer-const\n      requestPromises: any[] = []\n    const promise = new Promise((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    const requestAnnotation = (includeAttachmentIds: Array<string> = []) => {\n      const formData = new FormData()\n\n      formData.append('render', annotationJSON)\n\n      if (includeAttachmentIds.length > 0 && annotation.imageAttachmentId && blob) {\n        formData.append(annotation.imageAttachmentId, blob)\n      }\n\n      const doNotRequestWebP = width > MAX_WEBP_DIMENSION || height > MAX_WEBP_DIMENSION\n      const imageRequestPromise = new XHRImageRequest({\n        identifier: requestQueueId,\n        url: renderAnnotationURL,\n        token: this._state.imageToken,\n        payload: formData,\n        doNotRequestWebP,\n      })\n\n      const imageRequest = this._requestQueue.enqueue(imageRequestPromise, false)\n\n      imageRequest.promise\n        .then(result => {\n          if (isCanceled) {\n            return\n          }\n\n          if (result.attachmentsNotFound && !hasRetried) {\n            requestAnnotation(result.attachmentsNotFound)\n\n            return\n          }\n\n          if (result.attachmentsNotFound) {\n            rejectPromise(new PSPDFKitError('Attachment could not be found.'))\n\n            return\n          }\n\n          resolvePromise(result)\n        })\n        .catch(error => {\n          if (isCanceled) {\n            return\n          }\n\n          rejectPromise(error)\n        })\n      requestPromises.push(imageRequest)\n    }\n\n    requestAnnotation()\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n        requestPromises.forEach(request => {\n          request.cancel()\n        })\n      },\n    }\n  }\n\n  _requestRenderAnnotations = (\n    pageIndex: number,\n    annotationsPdfObjectIds: Array<number>,\n    widths: Array<number>,\n    heights: Array<number>,\n    formFieldValues: Array<FormFieldValueJSON>,\n  ): DiscardablePromise<Array<Blob | null | undefined>> => {\n    const renderAnnotationsURL = `${this._state.documentURL}/render_annotations`\n\n    const renderRequestJSON = JSON.stringify({\n      annotations: annotationsPdfObjectIds.map((pdfObjectId, index) => ({\n        pageIndex,\n        pdfObjectId,\n        width: widths[index],\n        height: heights[index],\n      })),\n      formFieldValues,\n    })\n\n    let resolvePromise\n    let rejectPromise\n    let isCanceled = false\n\n    const promise = new Promise<Array<Blob | null | undefined>>((resolve, reject) => {\n      resolvePromise = resolve\n      rejectPromise = reject\n    })\n\n    this._fetch(renderAnnotationsURL, {\n      method: 'post',\n      body: renderRequestJSON,\n      credentials: 'include',\n      headers: {\n        'X-PSPDFKit-Image-Token': this._state.imageToken,\n        'Content-Type': 'application/json',\n        Accept: 'multipart/form-data',\n      },\n    })\n\n      .then(res => res.formData())\n      .then((result: FormData) => {\n        if (isCanceled) {\n          return\n        }\n\n        // @ts-expect-error\n        resolvePromise(Array.from(result.values()))\n      })\n      .catch(error => {\n        if (isCanceled) {\n          return\n        }\n\n        rejectPromise(error)\n      })\n\n    return {\n      promise,\n      cancel: () => {\n        isCanceled = true\n      },\n    }\n  }\n\n  renderAnnotation(\n    annotation: Annotation,\n    formFieldValue: FormFieldValue | null | undefined,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n  ): {\n    promise: Promise<ImageHandle | null | undefined>\n    cancel: IFunction\n  } {\n    // @ts-expect-error\n    return this._requestRenderAnnotation(annotation, formFieldValue, blob, width, height)\n  }\n\n  async renderPageAnnotations(\n    pageIndex: number,\n    unfilteredAnnotations: List<Annotation>,\n    scaleFactor: number,\n  ): Promise<void> {\n    if (!supportsFormDataInResponse) {\n      // If formData() in responses is not (or not correctly) supported, fall back to individual AP stream rendering.\n      const pageAPStreamsPromise = Promise.resolve()\n\n      this.pageAPStreamsPromises = this.pageAPStreamsPromises.set(pageIndex, pageAPStreamsPromise)\n\n      return pageAPStreamsPromise\n    }\n\n    const provider = this.provider\n\n    const hasWidgets = unfilteredAnnotations.some(\n      annotation => annotation instanceof WidgetAnnotation,\n    )\n\n    if (hasWidgets) {\n      await provider._setReadStateCallbacksPromise\n    }\n\n    const formFieldValues: Array<FormFieldValueJSON> = []\n\n    // Filter out stamps, image and signature widgets, which do not get cached.\n    const annotations = unfilteredAnnotations.filter(annotation => {\n      const annotationWithFormField = hasWidgets\n        ? (provider._readStateCallbacks as ReadStateProviderCallbacks).getAnnotationWithFormField(\n            annotation.id,\n          )\n        : null\n      const formField = annotationWithFormField?.formField\n\n      const isCacheable = isCacheableAnnotationAPStream(annotation, formField)\n\n      if (isCacheable && formField && typeof annotation.pdfObjectId === 'number') {\n        const formFieldValueForFormField = formFieldValues.find(\n          formFieldValue => formFieldValue.name === formField.name,\n        )\n\n        if (!formFieldValueForFormField) {\n          formFieldValues.push(serializeFormFieldValue(formFieldValueFromFormField(formField)))\n        }\n      }\n\n      return isCacheable && typeof annotation.pdfObjectId === 'number'\n    })\n\n    if (annotations.size === 0 && formFieldValues.length === 0) {\n      return Promise.resolve()\n    }\n\n    const pageAPStreamsPromise = new Promise<void>((resolve, reject) => {\n      const { promise: renderPageAnnotationsCall, cancel } = this._requestRenderAnnotations(\n        pageIndex,\n        annotations.map(annotation => annotation.pdfObjectId).toArray() as number[],\n        annotations\n          .map(annotation => Math.floor(annotation.boundingBox.width * scaleFactor))\n          .toArray(),\n        annotations\n          .map(annotation => Math.floor(annotation.boundingBox.height * scaleFactor))\n          .toArray(),\n        formFieldValues,\n      )\n\n      renderPageAnnotationsCall\n        .then((pageAPStreamsBlobs: Array<Blob | null | undefined>) => {\n          // An array of blob with PNG images is received.\n          const imageHandlePromises: Array<Promise<ImageHandle> | null | undefined> =\n            pageAPStreamsBlobs.map(blob => blob && imageHandleFromBlob(blob))\n\n          imageHandlePromises.forEach(async (imageHandlePromise, index) => {\n            const imageHandle = await imageHandlePromise\n            const annotation: Annotation | undefined = annotations.get(index)\n\n            if (annotation) {\n              const annotationAPStreamPromiseResolve = this.annotationAPStreamPromises.get(\n                annotation.id,\n              )\n\n              // If there's a registered resolve callback, resolve with the imageHandle\n              if (annotationAPStreamPromiseResolve) {\n                this.annotationAPStreamPromises = this.annotationAPStreamPromises.delete(\n                  annotation.id,\n                )\n                annotationAPStreamPromiseResolve(imageHandle)\n              }\n\n              // Cache the imageHandle\n              imageHandle && this.cacheAPStream(imageHandle, annotation)\n            }\n          })\n          Promise.all(imageHandlePromises).then(() => resolve())\n        })\n        .catch(error => {\n          cancel()\n          reject(error)\n        })\n    })\n\n    // Store the promise so when cachedRenderAnnotation() is called, it can be awaited to ensure AP streams are available for rendering.\n    this.pageAPStreamsPromises = this.pageAPStreamsPromises.set(pageIndex, pageAPStreamsPromise)\n\n    return pageAPStreamsPromise\n  }\n\n  renderDetachedAnnotation(\n    annotation: Annotation,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n  ): {\n    promise: Promise<ImageHandle | null | undefined>\n    cancel: IFunction\n  } {\n    // @ts-expect-error\n    return this._requestRenderAnnotation(annotation, null, blob, width, height, true)\n  }\n\n  async getAttachment(attachmentId: string): Promise<Blob> {\n    try {\n      const res = await this._fetch(`${this._state.documentURL}/attachments/${attachmentId}`)\n\n      switch (res.status) {\n        case 404:\n          throw new PSPDFKitError('Attachment not Found.')\n\n        case 200:\n          return await res.blob()\n\n        default:\n          throw new PSPDFKitError('Bad Request.')\n      }\n    } catch (error) {\n      throw new PSPDFKitError(`Could not fetch attachment from PSPDFKit Server. ${error}`)\n    }\n  }\n\n  async search(\n    searchTerm: string,\n    startPageIndex: number,\n    limitPages: number,\n    caseSensitive: boolean,\n    searchInAnnotations = false,\n    searchType: ISearchType = SearchType.TEXT,\n  ): Promise<List<SearchResult>> {\n    const params = `q=${\n      searchType === SearchType.PRESET\n        ? searchTerm.replace(/_/g, '-')\n        : encodeURIComponent(searchTerm)\n    }&start=${startPageIndex}&limit=${limitPages}&type=${searchType}&include_annotations=${searchInAnnotations.toString()}&case_sensitive=${caseSensitive.toString()}`\n    const url = `${this._state.documentURL}/search?${params}`\n    const response = await new JSONRequest(url, this._state.token).request()\n\n    return parseJsonSearchResults(response.data)\n  }\n\n  async searchAndRedact(\n    term: string | ISearchPattern,\n    options: {\n      searchType: ISearchType\n      searchInAnnotations: boolean\n      caseSensitive: boolean\n      annotationPreset: RedactionAnnotationPreset\n    },\n  ): Promise<List<Annotation>> {\n    const { searchType, annotationPreset, searchInAnnotations, caseSensitive } = options\n    const { color, fillColor, outlineColor, ...rest } = annotationPreset\n    const res = await this._fetch(`${this._state.documentURL}/redactions`, {\n      method: 'post',\n      credentials: 'include',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        strategy: searchType,\n        strategyOptions: {\n          [searchType as string]: searchType === SearchType.PRESET ? term.replace(/_/g, '-') : term,\n          includeAnnotations: searchInAnnotations,\n          caseSensitive: caseSensitive,\n        },\n        content: {\n          ...rest,\n          color: color && color.toHex(),\n          fillColor: fillColor && fillColor.toHex(),\n          outlineColor: outlineColor && outlineColor.toHex(),\n        },\n      }),\n    })\n    const { data } = await res.json()\n\n    return List(\n      data && data.annotations\n        ? data.annotations.map(ann => RedactionAnnotationSerializer.fromJSON(ann.id, ann.content))\n        : [],\n    )\n  }\n\n  exportPDF({\n    flatten = false,\n    includeComments = true,\n    excludeAnnotations = false,\n  }: ExportPDFFlags = {}): Promise<ArrayBuffer> {\n    const url = `${this._state.documentURL}/pdf?token=${this._state.token}&flatten=${String(\n      flatten,\n    )}&comments=${String(includeComments)}&render_ap_streams=${String(\n      !flatten,\n    )}&remove_annotations=${String(excludeAnnotations)}`\n\n    return fetch(url, {\n      method: 'GET',\n      credentials: 'include',\n    }).then(r => r.arrayBuffer())\n  }\n\n  exportXFDF(): Promise<string> {\n    return this._fetch(`${this._state.documentURL}/document.xfdf`).then(res => res.text())\n  }\n\n  exportInstantJSON(): Promise<InstantJSON> {\n    return this._fetch(`${this._state.documentURL}/instant.json`).then(res => res.json())\n  }\n\n  getPDFURL({ includeComments = true, excludeAnnotations = false }: GetPDFURLFlags = {}): {\n    promise: Promise<string>\n    revoke: IFunction\n  } {\n    return {\n      promise: Promise.resolve(\n        `${this._state.documentURL}/pdf?token=${this._state.token}&flatten=true&comments=${String(\n          includeComments,\n        )}&remove_annotations=${String(excludeAnnotations)}`,\n      ),\n      revoke: () => {},\n    }\n  }\n\n  generatePDFObjectURL({\n    includeComments = true,\n    excludeAnnotations = false,\n  }: GeneratePDFObjectURLFlags = {}): {\n    promise: Promise<string>\n    revoke: IFunction\n  } {\n    let objectUrl,\n      isRevoked = false\n    const promise = new Promise<string>(resolve => {\n      this.exportPDF({\n        flatten: true,\n        includeComments,\n        excludeAnnotations,\n      }).then(arrayBuffer => {\n        if (isRevoked) {\n          return\n        }\n\n        const blob = new Blob([arrayBuffer], {\n          type: 'application/pdf',\n        })\n\n        objectUrl = window.URL.createObjectURL(blob)\n        resolve(objectUrl)\n      })\n    })\n\n    return {\n      promise,\n      revoke: () => {\n        if (objectUrl) {\n          window.URL.revokeObjectURL(objectUrl)\n        }\n\n        isRevoked = true\n      },\n    }\n  }\n\n  async getDocumentOutline(): Promise<List<OutlineElement>> {\n    let data\n\n    try {\n      const json = await this._fetch(`${this._state.documentURL}/outline.json`).then(res =>\n        res.json(),\n      )\n\n      data = json.data\n    } catch (e) {\n      data = {}\n    }\n\n    const outline = Array.isArray(data.outline) ? data.outline : []\n\n    return List(outline.map(documentOutlineFromJSON))\n  }\n\n  onKeystrokeEvent(): Promise<Array<ActionChange>> {\n    throw new Error('not implemented')\n  }\n\n  async applyOperationsAndReload(operations: Array<DocumentOperationJSON>): Promise<LoadResponse> {\n    try {\n      const body = await createOperationsPayload(operations)\n\n      this._destroyProvider()\n\n      await this._fetch(`${this._state.documentURL}/apply-operations`, {\n        method: 'post',\n        body,\n        credentials: 'include',\n      })\n    } catch (e) {\n      throw new PSPDFKitError(`Applying operations failed: ${e}`)\n    }\n\n    return this.reloadDocument()\n  }\n\n  async applyRedactionsAndReload(): Promise<LoadResponse> {\n    try {\n      this._destroyProvider()\n\n      await this._fetch(`${this._state.documentURL}/redact`, {\n        method: 'post',\n        credentials: 'include',\n      })\n\n      return this.reloadDocument()\n    } catch (e) {\n      // We rollback from destroying the provider if redacting fails. Otherwise,\n      // no further updates are sent to the current provider.\n      this.provider.load()\n      throw new PSPDFKitError(`Applying redactions failed: ${e}`)\n    }\n  }\n\n  async reloadDocument(): Promise<LoadResponse> {\n    try {\n      return await this.load({\n        password: this._password,\n      })\n    } catch (e) {\n      throw new PSPDFKitError(`Reloading the document failed: ${e}`)\n    }\n  }\n\n  async exportPDFWithOperations(operations: Array<DocumentOperationJSON>): Promise<ArrayBuffer> {\n    try {\n      const body = await createOperationsPayload(operations)\n\n      return this._fetch(`${this._state.documentURL}/pdf-with-operations`, {\n        method: 'post',\n        body,\n        credentials: 'include',\n      }).then(res => res.arrayBuffer())\n    } catch (e) {\n      throw new PSPDFKitError(`Exporting PDF with operations failed: ${e}`)\n    }\n  }\n\n  async getSignaturesInfo(): Promise<SignaturesInfo> {\n    if (this._refreshSignaturesInfoPromise) {\n      await this._refreshSignaturesInfoPromise\n    }\n\n    return this._state.digitalSignatures\n  }\n\n  refreshSignaturesInfo(): Promise<void> {\n    if (this._refreshSignaturesInfoPromise) {\n      return this._refreshSignaturesInfoPromise\n    }\n\n    this._refreshSignaturesInfoPromise = new Promise((resolve, reject) => {\n      this._fetch(`${this._state.documentURL}/signatures`, {\n        method: 'get',\n        credentials: 'include',\n      })\n        .then(res => res.json())\n        .then(({ data: digitalSignatures }) => {\n          this._state = this._state.set(\n            'digitalSignatures',\n            deserializeSignaturesInfo(digitalSignatures),\n          )\n          this._refreshSignaturesInfoPromise = null\n          resolve()\n        })\n        .catch(error => {\n          this._state = this._state.set('digitalSignatures', null)\n          this._refreshSignaturesInfoPromise = null\n          reject(error)\n        })\n    })\n\n    return this._refreshSignaturesInfoPromise\n  }\n\n  async signDocumentAndReload(\n    signaturePreparationData: SignaturePreparationData | null | undefined,\n    signingServiceData: TwoStepSignatureCallback | (SigningServiceData | null | undefined),\n  ): Promise<void> {\n    try {\n      if (signingServiceData !== undefined && typeof signingServiceData !== 'object') {\n        throw new PSPDFKitError('Signing service data must be an object if specified.')\n      }\n\n      const additionalParams: any = {}\n\n      if (signaturePreparationData && 'placeholderSize' in signaturePreparationData) {\n        additionalParams.signerDataSource = {\n          estimatedSize: signaturePreparationData.placeholderSize,\n        }\n      }\n\n      if (signaturePreparationData && 'flatten' in signaturePreparationData) {\n        additionalParams.flatten = signaturePreparationData.flatten\n      }\n\n      const body = {\n        ...(signingServiceData\n          ? {\n              signingToken: signingServiceData.signingToken,\n            }\n          : null),\n        ...additionalParams,\n      }\n\n      // We destroy the provider because during signing, a new form field and\n      // widget annotation are created. Afterwards, we reload the document and\n      // update the layerHandle, bailing out from the changes propagation back\n      // to the managers flow.\n      this._destroyProvider()\n\n      await this._fetch(`${this._state.documentURL}/sign`, {\n        method: 'post',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(body),\n        credentials: 'include',\n      })\n      await this.reloadDocument()\n    } catch (e) {\n      // We rollback from destroying the provider if signing fails. Otherwise,\n      // no further updates are sent to the current provider.\n      this.provider.load()\n      throw new PSPDFKitError(`Adding digital signature failed: ${e.message || e}`)\n    }\n  }\n\n  handleDocumentHandleConflict = () => {\n    this._state = this._state.set('isDocumentHandleOutdated', true)\n    this.cancelRequests()\n\n    this._destroyProvider()\n  }\n\n  getDocumentHandle() {\n    return this._state.documentHandle\n  }\n\n  async getEmbeddedFiles(): Promise<List<EmbeddedFile>> {\n    const res = await this._fetch(`${this._state.documentURL}/embedded-files`, {\n      method: 'get',\n      credentials: 'include',\n    })\n\n    const data = await res.json()\n\n    return List(\n      data?.data?.embeddedFiles?.length\n        ? data.data.embeddedFiles.map(({ id, content }) => fromJSON(id, content))\n        : [],\n    )\n  }\n\n  // Cancels all current requests and removes all associated promises.\n  cancelRequests() {\n    this._requestQueue.cancelAll()\n  }\n\n  _destroyProvider() {\n    if (this.provider) {\n      // @ts-expect-error\n      this.provider._clients && this.provider._clients.disconnect()\n      this.provider.destroy()\n    }\n  }\n\n  async _fetch(url: string, options?: RequestInit): Promise<Response> {\n    const response = await fetch(url, {\n      ...options,\n      headers: {\n        ...options?.headers,\n        'X-PSPDFKit-Token': this._state.token,\n        'PSPDFKit-Platform': 'web',\n        'PSPDFKit-Version': getVersionHeader(),\n      },\n    })\n\n    if (!response.ok) {\n      let bodyMessage = await parseAsJSONOrString(response)\n\n      bodyMessage = typeof bodyMessage === 'object' ? bodyMessage.reason : bodyMessage\n\n      const message = bodyMessage || `${response.status} ${response.statusText}`\n\n      throw new PSPDFKitError(message)\n    }\n\n    return response\n  }\n\n  syncChanges(): Promise<void> {\n    return this.provider.syncChanges()\n  }\n\n  // No-op in Server mode.\n  async clearAPStreamCache(): Promise<void> {}\n\n  async runPDFFormattingScripts(): Promise<ActionChange[]> {\n    return []\n  }\n\n  // We don't require any lazy loading in Server.\n  async lazyLoadPages(): Promise<void> {}\n}\n\nfunction parseAsJSONOrString(response: Response) {\n  // The response stream needs to be cloned before attempting\n  // to read from it again (in case we need to fallback to text\n  // parsing)\n  return response\n    .clone()\n    .json()\n    .catch(() => response.text())\n}\n\nasync function createOperationsPayload(operations) {\n  const operationsDocuments = {}\n  // If multiple operations use the same blob, we only want to send it once.\n  // We track blobs that have already been appended in a WeakMap(blob => index)\n  const blobWeakMap = new WeakMap()\n  const processedOperations = await Promise.all(\n    operations.map(async (operation, index): Promise<DocumentOperationJSON> => {\n      if (operation.type === 'importDocument') {\n        const document = operation.document\n\n        invariant(\n          document instanceof File || document instanceof Blob,\n          'Wrong `importDocument` operation `document` value: it must be a File or a Blob',\n        )\n\n        return addBlobToWeakMap(\n          blobWeakMap,\n          operationsDocuments,\n          document,\n          operation,\n          index,\n          'document',\n        )\n      } else if (operation.type === 'applyInstantJson') {\n        const value = operation.instantJson\n\n        invariant(\n          typeof value === 'object' && value !== null,\n          'Wrong `applyInstantJson` operation `instantJson` value: it must be an object',\n        )\n\n        const string = JSON.stringify(value)\n        const document = new Blob([string], {\n          type: 'application/json',\n        })\n\n        return addBlobToWeakMap(\n          blobWeakMap,\n          operationsDocuments,\n          document,\n          operation,\n          index,\n          'dataFilePath',\n        )\n      } else if (operation.type === 'applyXfdf') {\n        const value = operation.xfdf\n\n        invariant(\n          typeof value === 'string',\n          'Wrong `applyXfdf` operation `xfdf` value: it must be a string',\n        )\n\n        const document = new Blob([value], {\n          type: 'application/vnd.adobe.xfdf',\n        })\n\n        return addBlobToWeakMap(\n          blobWeakMap,\n          operationsDocuments,\n          document,\n          operation,\n          index,\n          'dataFilePath',\n        )\n      }\n\n      return operation\n    }),\n  )\n  const formData = new FormData()\n\n  formData.append(\n    'operations',\n    JSON.stringify({\n      operations: processedOperations,\n    }),\n  )\n\n  for (const document in operationsDocuments) {\n    formData.append(document, operationsDocuments[document])\n  }\n\n  return formData\n}\n\nfunction validateInstantSetting(instant: boolean | InstantSettings) {\n  let error = ''\n\n  // Validate instant property.\n  if (typeof instant !== 'boolean') {\n    if (isPlainObject(instant)) {\n      if (\n        instant.hasOwnProperty('clientsPresenceEnabled') &&\n        typeof instant['clientsPresenceEnabled'] !== 'boolean'\n      ) {\n        error +=\n          '`clientsPresenceEnabled` in instance settings is not valid. Must be `true` or `false`.\\n'\n      }\n\n      if (\n        instant.hasOwnProperty('listenToServerChangesEnabled') &&\n        typeof instant['listenToServerChangesEnabled'] !== 'boolean'\n      ) {\n        error +=\n          '`listenToServerChangesEnabled` in instance settings is not valid. Must be `true` or `false`.\\n'\n      }\n    } else {\n      error = '`instant` flag must either be set to `true` or `false`\\n'\n    }\n\n    if (error) {\n      throw new PSPDFKitError(`${error}\nFor more information about PSPDFKit Instant please visit:\nhttps://pspdfkit.com/guides/web/current/instant/overview/`)\n    }\n  }\n}\n\nfunction resolveServerUrl(configuration: ServerConfiguration, _window: Window = window): string {\n  const serverUrl = configuration.serverUrl || getBaseUrl(_window.document)\n\n  // serverUrl must have a slash at the end\n  if (serverUrl.substr(-1) !== '/') {\n    throw new PSPDFKitError(\n      '`serverUrl` must have a slash at the end (e.g. `https://pspdfkit.example.com/`).',\n    )\n  }\n\n  // Verify that the base URL is different from the current browser's location. If it's the same,\n  // we assume that we haven't loaded PSPDFKit for Web from the Server origin and bail out. If\n  // the `serverUrl` is explicitly set in the configuration, we will always use it\n  if (!configuration.serverUrl) {\n    // There were some problems with `window.location.origin` in IE11 on Win10 [1], that's why\n    // we use `window.location.host` instead.\n    // [1]: https://goo.gl/5D5mNX\n    const browserOrigin = `${_window.location.protocol}//${_window.location.host}/`\n\n    if (serverUrl === browserOrigin) {\n      throw new PSPDFKitError(`PSPDFKit automatically infers the URL of PSPDFKit Server from the current \\`<script>\\` tag.\nIn the current case, this URL is set to the same as the current browser's location.\nThis can happen when you bundle pspdfkit.js with your custom JavaScript for example.\n\nTo make sure everything works as expected, please set the \\`serverUrl\\` to the URL of PSPDFKit Server:\n\nPSPDFKit.load({\n  serverUrl: \"https://pspdfkit-server.example.com/\",\n  ...,\n});`)\n    }\n  }\n\n  return serverUrl\n}\n","/**\n * This object contains detailed Instant settings.\n *\n * @private\n * @memberof PSPDFKit\n * @interface InstantSettings\n * @server\n * @example\n * PSPDFKit.load({\n *   instant: {\n *      clientPresenceEnabled: false,\n *      listenToServerChangesEnabled: false\n *   }\n * });\n * @seealso PSPDFKit.Configuration.instant\n */\n\n/**\n * Controls whether the client presence tracking is enabled.\n *\n * When this flag is set to `true`, a single WebSocket connection is kept open to get up to date\n * information about currently connected instance clients.\n *\n * When this flag is set to `false`, client presence tracking will be disabled. This means that\n * {@link PSPDFKit.Instance#connectedClients} will return an empty map and\n * the {@link PSPDFKit.Instance~ConnectedClientsChangeEvent} won't be triggered.\n *\n * @private\n * @instance\n * @member {boolean} clientsPresenceEnabled\n * @memberof PSPDFKit.InstantSettings\n * @default true\n */\n\n/**\n * Controls whether to listen to server changes.\n *\n * When this flag is set to `true`, changes will be pulled immediately. Single HTTP connection is\n * kept open to listen to server changes in this case.\n *\n * When this flag is set to `false`, Instant won't listen to changes made by other connected clients.\n * It's clients responsibility to call {@link PSPDFKit.Instance#syncChanges} to pull latest changes.\n *\n * @private\n * @instance\n * @member {boolean} listenToServerChangesEnabled\n * @memberof PSPDFKit.InstantSettings\n * @default true\n */\nexport type InstantSettings = {\n  clientsPresenceEnabled?: boolean\n  listenToServerChangesEnabled?: boolean\n}\n\nexport const defaultInstantSettings: InstantSettings = {\n  clientsPresenceEnabled: true,\n  listenToServerChangesEnabled: true,\n}\n"],"names":["authenticate","documentURL","authPayload","password","fetch","method","headers","getVersionHeader","body","JSON","stringify","jwt","origin","window","location","href","credentials","res","ok","json","text","then","message","PSPDFKitError","statusText","authenticateHostedDocument","hostedBaseUrl","accessToken","Accept","PSPDFKIT_DEFINES","Error","validateJWT","JWT_INVALID","indexOf","userContent","invariant","split","length","Base64","parse","e","document_id","validateDocumentAccessToken","ServerBackendState","Immutable","serverUrl","documentId","backendPermissions","imageToken","instantSettings","token","features","List","signatureFeatureAvailability","SignatureFeatureAvailability","isFormsEnabled","minSearchQueryLength","documentHandle","isDocumentHandleOutdated","digitalSignatures","defaultGroup","undefined","hasCollaborationPermissions","forceLegacySignaturesFeature","GENERIC_RENDER_ERROR","XHRImageRequest","identifier","url","payload","doNotRequestWebP","this","httpRequest","abort","Promise","resolve","reject","XMLHttpRequest","open","setRequestHeader","webp","responseType","onreadystatechange","readyState","response","type","startsWith","fileReader","FileReader","onload","event","target","result","attachments_not_found","attachmentsNotFound","error","onerror","readAsText","requestIsSuccess","status","blob","objectUrl","URL","createObjectURL","img","Image","src","imagePromise","decode","setTimeout","ImageHandle","revokeObjectURL","bind","send","ServerBackend","configuration","_window","annotation","formFieldValue","width","height","detached","resolvePromise","rejectPromise","renderAnnotationURL","_state","requestQueueId","ulid","id","annotationJSON","data","serializeAnnotation","serializeFormFieldValue","isCanceled","requestPromises","promise","requestAnnotation","includeAttachmentIds","formData","FormData","append","imageAttachmentId","imageRequestPromise","MAX_WEBP_DIMENSION","imageRequest","_requestQueue","enqueue","catch","push","cancel","forEach","request","pageIndex","annotationsPdfObjectIds","widths","heights","formFieldValues","renderAnnotationsURL","renderRequestJSON","annotations","map","pdfObjectId","index","_fetch","Array","from","values","set","cancelRequests","_destroyProvider","documentUrl","validateHostedBaseUrl","resolveServerUrl","validateInstantSetting","instant","isPlainObject","settings","clientsPresenceEnabled","listenToServerChangesEnabled","defaultInstantSettings","RequestQueue","MAX_RESOURCE_REQUESTS_IN_QUEUE_SERVER","electronicSignatures","Boolean","disableForms","warn","options","tryAuthenticateHostedViewer","permissions","hasPassword","layerHandle","allowedTileScales","collaborationPermissions","creatorName","_password","includes","LicenseFeature","finalSignatureFeatureAvailability","withMutations","state","BackendPermissions","readOnly","downloadingAllowed","deserializeSignaturesInfo","provider","destroy","_initProvider","setDocumentHandleConflictCallback","handleDocumentHandleConflict","serverId","InstantProvider","auth_token","RESTProvider","v","fields","pageTextRequestURL","jsonRequestPromise","_getJSONRequestHandler","jsonToTextLines","rects","rectsParam","encodeURIComponent","rectToJSON","toArray","JSONRequest","pageSize","tileRect","renderForPrinting","contentState","imageTileURL","left","top","hasPriority","hasRetried","requestImages","requestTile","filter","isModifiableAnnotation","toJS","content","formFields","serializeFormField","signatures","attachment","attachments","get","tile","_requestRenderAnnotation","unfilteredAnnotations","scaleFactor","supportsFormDataInResponse","pageAPStreamsPromise","pageAPStreamsPromises","hasWidgets","some","WidgetAnnotation","_setReadStateCallbacksPromise","annotationWithFormField","_readStateCallbacks","getAnnotationWithFormField","formField","isCacheable","isCacheableAnnotationAPStream","find","name","formFieldValueFromFormField","size","_requestRenderAnnotations","Math","floor","boundingBox","renderPageAnnotationsCall","pageAPStreamsBlobs","imageHandlePromises","imageHandleFromBlob","imageHandlePromise","imageHandle","annotationAPStreamPromiseResolve","annotationAPStreamPromises","delete","cacheAPStream","all","attachmentId","searchTerm","startPageIndex","limitPages","caseSensitive","searchInAnnotations","searchType","SearchType","params","replace","toString","parseJsonSearchResults","term","annotationPreset","color","fillColor","outlineColor","rest","strategy","strategyOptions","toHex","ann","RedactionAnnotationSerializer","flatten","includeComments","excludeAnnotations","String","r","arrayBuffer","revoke","isRevoked","exportPDF","Blob","outline","isArray","documentOutlineFromJSON","operations","createOperationsPayload","reloadDocument","load","_refreshSignaturesInfoPromise","signaturePreparationData","signingServiceData","additionalParams","signerDataSource","estimatedSize","placeholderSize","signingToken","embeddedFiles","fromJSON","cancelAll","_clients","disconnect","parseAsJSONOrString","bodyMessage","reason","syncChanges","SharedBackend","clone","operationsDocuments","blobWeakMap","WeakMap","operation","document","File","addBlobToWeakMap","value","instantJson","string","xfdf","processedOperations","hasOwnProperty","getBaseUrl","substr","browserOrigin","protocol","host"],"sourceRoot":""}