{"version":3,"file":"pspdfkit-lib/chunk-6401-9d75eee2dba161d5.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/SharedBackend.ts","webpack://PSPDFKit/./src/lib/requests/RequestQueue.ts","webpack://PSPDFKit/./src/models/EmbeddedFile.ts","webpack://PSPDFKit/./src/lib/serializers/EmbeddedFileSerializer.ts","webpack://PSPDFKit/./src/utils/documentOperations.ts","webpack://PSPDFKit/./src/utils/search.ts"],"sourcesContent":["import { Map } from 'immutable'\nimport { Annotation, WidgetAnnotation, FormFieldValue, SignatureFormField } from '../models'\nimport { invariant } from '@pspdfkit/shared'\nimport { isCacheableAnnotationAPStream } from '@/utils/annotation'\nimport type { ID } from '@/models/annotations/Annotation'\nimport type { Set } from 'immutable'\nimport type ImageHandle from '../lib/handles/ImageHandle'\nimport type { Backend } from '@/typings/backend'\nimport { IFunction } from '@/typings/utils'\n\n/**\n * SharedBackend\n *\n * This class contains code that can be reused by both StandaloneBackend and SharedBackend, which extend it.\n *\n * Methods and instance variables that are identical in both backends can be moved here so as to reduce\n * the amount of moving parts and therefore the chance for errors.\n */\nexport class SharedBackend {\n  cachedAPStreams: Map<number, Map<ID, ImageHandle>> = Map()\n  pageAPStreamsPromises: Map<number, Promise<void>> = Map()\n  annotationAPStreamPromises: Map<ID, (arg0: ImageHandle | null | undefined) => void> = Map()\n\n  /**\n   * Processes a renderAnnotation request with the following rules:\n   *\n   * - If the annotation AP stream is non-cacheable, it calls renderAnnotation() right away.\n   * - If the annotation AP stream is cacheable, it waits for the page AP streams to be available if needed.\n   * - If the AP stream is available it resolves with it. Otherwise, it calls renderAnnotation().\n   */\n  cachedRenderAnnotation(\n    annotation: Annotation,\n    blob: Blob | null | undefined,\n    width: number,\n    height: number,\n  ): {\n    promise: Promise<ImageHandle | null | undefined>\n    cancel: IFunction\n  } {\n    const provider = (this as any as Backend).provider\n\n    invariant(\n      provider instanceof provider.constructor,\n      'Backend can only use backend annotation provider',\n    )\n\n    // For widget annotations, we need the associated form field to render the widget with the current value.\n    const formField =\n      annotation instanceof WidgetAnnotation\n        ? provider._readStateCallbacks?.getFormFieldByName(annotation.formFieldName)\n        : null\n    const formFieldValue =\n      formField && !(formField instanceof SignatureFormField)\n        ? new FormFieldValue({\n            name: formField.name,\n            // We will not be running JS when rendering the widget, so we pass the\n            // formatted value if available.\n            value:\n              typeof formField.formattedValue !== 'undefined'\n                ? formField.formattedValue\n                : typeof formField.value === 'string'\n                ? formField.value\n                : formField.values,\n          })\n        : null\n\n    // images, stamps, unknown annotation types and signature widgets AP streams are not cached in the backend instance.\n    if (!isCacheableAnnotationAPStream(annotation, formField)) {\n      return (this as unknown as Backend).renderAnnotation(\n        annotation,\n        formFieldValue,\n        blob,\n        width,\n        height,\n      )\n    }\n\n    let cancelled = false\n\n    let cancelPromise = () => {\n      cancelled = true\n    }\n\n    return {\n      // eslint-disable-next-line no-async-promise-executor\n      promise: new Promise(async (resolve, reject) => {\n        const cleanResolve = imageHandle => {\n          // Instead of just resolving with the image handle, we first delete the registered\n          // resolve callback from the backend promise resolve map.\n          const annotationAPStreamPromiseResolve = this.annotationAPStreamPromises.get(\n            annotation.id,\n          )\n\n          if (annotationAPStreamPromiseResolve) {\n            this.annotationAPStreamPromises = this.annotationAPStreamPromises.delete(annotation.id)\n            annotationAPStreamPromiseResolve(imageHandle)\n          }\n        }\n\n        // Check if a previous renderAnnotation() request is waiting.\n        const annotationAPStreamPromiseResolve = this.annotationAPStreamPromises.get(annotation.id)\n\n        // Register the new resolve callback.\n        this.annotationAPStreamPromises = this.annotationAPStreamPromises.set(\n          annotation.id,\n          resolve,\n        )\n\n        // Resolve any previous request with null to prevent the calling image component from stalling.\n        if (annotationAPStreamPromiseResolve) {\n          annotationAPStreamPromiseResolve(null)\n        }\n\n        try {\n          // Retrieve the current page's AP streams render promise.\n          const pageAPStreamsPromise = this.pageAPStreamsPromises.get(annotation.pageIndex)\n\n          if (!pageAPStreamsPromise) {\n            // If the promise is not available, it means that renderPageAnnotations() has not been called yet\n            // for this page. Therefore we register the resolve callback so it gets called when renderPageAnnotations()\n            // is called and resolves.\n            const annotationAPStreamPromise = new Promise(resolve => {\n              this.annotationAPStreamPromises = this.annotationAPStreamPromises.set(\n                annotation.id,\n                resolve,\n              )\n            })\n\n            // Wait for the registered resolve callback to be called.\n            const imageHandle = (await annotationAPStreamPromise) as ImageHandle\n\n            resolve(imageHandle)\n\n            return\n          } else {\n            // Wait for the page AP streams to be available.\n            await pageAPStreamsPromise\n          }\n\n          const cachedPageAPStreams = this.cachedAPStreams.get(annotation.pageIndex)\n\n          // Are there already cached AP streams for this page?\n          if (cachedPageAPStreams) {\n            // Is there already a cached AP stream for the annotation?\n            const cachedAPStream = cachedPageAPStreams\n              ? cachedPageAPStreams.get(annotation.id)\n              : null\n\n            if (cachedAPStream) {\n              // Then resolve with the cached AP stream\n              cleanResolve(cachedAPStream)\n\n              return\n            }\n          }\n\n          // In any other case, render the annotation.\n          const { promise, cancel } = (this as unknown as Backend).renderAnnotation(\n            annotation,\n            formFieldValue,\n            blob,\n            width,\n            height,\n          )\n\n          if (cancelled) {\n            cleanResolve(null)\n          } else {\n            cancelPromise = cancel\n\n            const imageHandle = await promise\n\n            cleanResolve(imageHandle)\n            imageHandle && this.cacheAPStream(imageHandle, annotation)\n          }\n        } catch (e) {\n          reject(e)\n        }\n      }),\n      cancel: cancelPromise,\n    }\n  }\n\n  // Stores the provided imageHandle for caching under the pageIndex, annotation.id key\n  cacheAPStream(imageHandle: ImageHandle, annotation: Annotation) {\n    let cachedPageAPStreams = this.cachedAPStreams.get(annotation.pageIndex)\n\n    if (!cachedPageAPStreams) {\n      this.cachedAPStreams = this.cachedAPStreams.set(annotation.pageIndex, Map())\n      cachedPageAPStreams = this.cachedAPStreams.get(annotation.pageIndex)\n    }\n\n    invariant(cachedPageAPStreams)\n\n    this.cachedAPStreams = this.cachedAPStreams.setIn(\n      [annotation.pageIndex, annotation.id],\n      imageHandle,\n    )\n  }\n\n  // Releases and removes all AP streams cached for a given page.\n  // Called when AnnotationLayerComponent unmounts.\n  clearAllPageAPStreams(pageIndex: number) {\n    const cachedPageAPStreams = this.cachedAPStreams.get(pageIndex)\n\n    if (cachedPageAPStreams) {\n      cachedPageAPStreams.forEach(APStream => {\n        APStream.release()\n      })\n      this.cachedAPStreams = this.cachedAPStreams.delete(pageIndex)\n    }\n\n    this.pageAPStreamsPromises = this.pageAPStreamsPromises.delete(pageIndex)\n  }\n\n  // Releases and removes the specified AP streams cached for a given page.\n  // Called when an annotation's AP stream is invalidated.\n  clearPageAPStreams(pageIndex: number, annotationIds: Set<ID>) {\n    const cachedPageAPStreams = this.cachedAPStreams.get(pageIndex)\n\n    if (cachedPageAPStreams) {\n      cachedPageAPStreams\n        .filter((_APStream, annotationId) => annotationIds.has(annotationId))\n        .forEach(APStream => {\n          APStream.release()\n        })\n      this.cachedAPStreams = this.cachedAPStreams.updateIn([pageIndex], cachedPageAPStreams =>\n        cachedPageAPStreams.filter((_APStream, annotationId) => !annotationIds.has(annotationId)),\n      )\n    }\n  }\n}\n","import { OrderedMap, Map, set } from 'immutable'\nimport { Request } from './types/Request'\nimport { invariant } from '../../utils/invariant'\n\ntype PromiseTuple = {\n  promise: Promise<any>\n  resolve: (arg0: any) => unknown\n  reject: (arg0: any) => unknown\n}\n\nfunction functionThatReturnsTrue() {\n  return true\n}\n/**\n * The request queue is used by all backends in order to throttle concurrent\n * requests to common resources and to have a mechanism for the UI to declare\n * resources as unnecessary so that we avoid expensive computation/IO time.\n *\n * Resources can be enqueued with normal and high priority. The queue will\n * process resources that have a high priority before normal priority resources\n * (starvation, the issue that high priority work cause low priority work to\n * never run, is not handled). A maximum number of inflight requests can be\n * configured to limit concurrent requests.\n *\n * Inflight requests are not cancelled when the cancel callback is called. They\n * are just flagged as \"cancelled\" and their responses are ignored (we noop).\n * Cancellation only affects queued requests which are then removed from the\n * queue.\n */\n\nexport default class RequestQueue {\n  queue: OrderedMap<Request, PromiseTuple>\n  priorityQueue: OrderedMap<Request, PromiseTuple>\n  inFlightRequests: Map<Request, PromiseTuple>\n  inflightRequestLimit: number\n  isDestroyed: boolean\n\n  constructor(inflightRequestLimit: number) {\n    this.queue = OrderedMap()\n    this.priorityQueue = OrderedMap()\n    this.inFlightRequests = Map()\n    this.inflightRequestLimit = inflightRequestLimit\n    this.isDestroyed = false\n  }\n\n  /**\n   * Enqueues the given `request` and returns a promise, which resolves with the\n   * response from the request. It's important to save the returned promise and\n   * not call `.then` on it, otherwise you would get a new promise back, since\n   * Promises are immutable.\n   *\n   * Enqueuing a request doesn't mean that your given request got resolved, but\n   * you're listening now on the given response of this request.\n   *\n   * @example\n   * const { promise, cancel } = requestQueue.enqueue(request)\n   * promise.then(function (response) {\n   *  // you code goes here\n   * })\n   */\n  enqueue(\n    request: Request,\n    hasPriority = false,\n  ): {\n    promise: Promise<any>\n    cancel: () => void\n  } {\n    if (this.isDestroyed) {\n      return {\n        promise: new Promise(() => {}),\n        cancel: () => {},\n      }\n    }\n\n    const cancel = () => {\n      return this._cancel(request)\n    }\n\n    // We need the any cast here as flow does not know that the resolve and\n    // reject functions are initialized synchronously.\n    let resolve: any = null\n    let reject: any = null\n    const promise = new Promise((resolveFn, rejectFn) => {\n      resolve = resolveFn\n      reject = rejectFn\n    })\n    const targetQueue: OrderedMap<Request, PromiseTuple> = hasPriority\n      ? this.priorityQueue\n      : this.queue\n    const newQueue = set(targetQueue, request, {\n      promise,\n      resolve,\n      reject,\n    } as PromiseTuple)\n\n    if (hasPriority) {\n      this.priorityQueue = newQueue\n    } else {\n      this.queue = newQueue\n    }\n\n    if (hasPriority) {\n      // We can resolve the new requests immediately\n      this.next()\n    } else {\n      // Resolve the new request asynchronously so that other requests with\n      // `hasPriority: true` fires first.\n      setTimeout(() => this.next(), 35)\n    }\n\n    return {\n      promise,\n      cancel,\n    }\n  }\n\n  _cancel(request: Request): void {\n    if (this.queue.has(request)) {\n      this.queue = this.queue.delete(request)\n    }\n\n    if (this.priorityQueue.has(request)) {\n      this.priorityQueue = this.priorityQueue.delete(request)\n    }\n\n    if (this.inFlightRequests.has(request)) {\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n  }\n\n  /**\n   * Cancels all the requests and removes all the promises\n   */\n  cancelAll(): void {\n    this.queue = OrderedMap()\n    this.priorityQueue = OrderedMap()\n    this.inFlightRequests = Map()\n  }\n\n  /**\n   * Resolves and then removes the queued request, identified by the given\n   * `url`. Also starts the next request in the queue\n   */\n  _requestFinished(request: Request, response: any): void {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const promiseTuple = this.inFlightRequests.get(request)\n\n    if (promiseTuple) {\n      promiseTuple.resolve(response)\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n\n    this.next()\n  }\n\n  /**\n   * Rejects promise with given error and queues next request\n   */\n  _requestFailed(request: Request, error: Error) {\n    if (this.isDestroyed) {\n      return\n    }\n\n    const promiseTuple = this.inFlightRequests.get(request)\n\n    if (promiseTuple) {\n      promiseTuple.reject(error)\n      this.inFlightRequests = this.inFlightRequests.delete(request)\n    }\n\n    this.next()\n  }\n\n  /**\n   * Queues next request\n   */\n  next() {\n    if (this.isDestroyed) {\n      return\n    }\n\n    if (this.inFlightRequests.size >= this.inflightRequestLimit) {\n      return\n    }\n\n    if (this.priorityQueue.size >= 1) {\n      // Use LIFO, because we want to see the overviews that get loaded last\n      // first (because often these are the tiles that came into the viewport).\n      const lastEntry: void | [Request, PromiseTuple] =\n        this.priorityQueue.findLastEntry(functionThatReturnsTrue)\n\n      invariant(lastEntry)\n\n      const [request, promiseTuple] = lastEntry\n\n      this.priorityQueue = this.priorityQueue.delete(request)\n      this.inFlightRequests = this.inFlightRequests.set(request, promiseTuple)\n      request\n        .request()\n        .then(response => this._requestFinished(request, response))\n        .catch(error => this._requestFailed(request, error))\n\n      return\n    }\n\n    if (this.queue.size >= 1) {\n      const lastEntry: void | [Request, PromiseTuple] =\n        this.queue.findEntry(functionThatReturnsTrue)\n\n      invariant(lastEntry)\n\n      const [request, promiseTuple] = lastEntry\n\n      this.queue = this.queue.delete(request)\n      this.inFlightRequests = this.inFlightRequests.set(request, promiseTuple)\n      request\n        .request()\n        .then(response => this._requestFinished(request, response))\n        .catch(error => this._requestFailed(request, error))\n\n      return\n    }\n  }\n\n  destroy() {\n    this.isDestroyed = true\n  }\n}\n","import * as Immutable from 'immutable'\nimport { ID } from '@/models/annotations/Annotation'\n\nexport interface IEmbeddedFile {\n  id: ID\n  attachmentId: string\n  description: null | string\n  fileName: null | string\n  fileSize: null | number\n  updatedAt: null | Date\n}\n\n/**\n * @classdesc\n * This record is used to persist the information for an embedded file.\n * @public\n * @memberof PSPDFKit\n * @summary Embedded File.\n * @class EmbeddedFile\n * @noconstructor\n * @extends Immutable.Record\n * @seealso PSPDFKit.Instance#getEmbeddedFiles\n * @seealso PSPDFKit.Instance#getAttachment\n */\n\nexport class EmbeddedFile extends Immutable.Record<IEmbeddedFile>({\n  id: '',\n\n  /**\n   * A unique identifier that can be used to fetch the contents of the file.\n   *\n   * ```js\n   * const embeddedFiles = await instance.getEmbeddedFiles()\n   *\n   * const file = await instance.getAttachment(embeddedFiles.get(0).attachmentId)\n   * ```\n   *\n   * @public\n   * @instance\n   * @member {string} attachmentId\n   * @memberof PSPDFKit.EmbeddedFile\n   */\n  attachmentId: '',\n\n  /**\n   * The description of the file if present.\n   *\n   * @public\n   * @instance\n   * @member {?string} description\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  description: null,\n\n  /**\n   * The name of the file with extension.\n   *\n   * @public\n   * @instance\n   * @member {?string} fileName\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  fileName: null,\n\n  /**\n   * Size of the file in bytes.\n   *\n   * @public\n   * @instance\n   * @member {?number} fileSize\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  fileSize: null,\n\n  /**\n   * The date on which the embedded file was updated.\n   *\n   * @public\n   * @instance\n   * @member {?Date} updatedAt\n   * @memberof PSPDFKit.EmbeddedFile\n   * @default null\n   */\n  updatedAt: null,\n}) {}\n","import { ID } from '@/models/annotations/Annotation'\nimport { EmbeddedFile } from '@/models/EmbeddedFile'\nimport { generateInstantId } from '@/models/InstantID'\n\ninterface ISerialisedEmbeddedFileServer {\n  contentType: string\n  description: string\n  fileAttachmentId: string\n  fileName: string\n  fileSize: number\n  type: string\n  updatedAt: string\n  v: number\n}\n\ninterface ISerialisedEmbeddedFileStandalone {\n  fileName?: string\n  fileDescription?: string\n  modificationDate?: string\n  fileSize?: number\n}\n\nfunction isStandalone(\n  _content: ISerialisedEmbeddedFileServer | ISerialisedEmbeddedFileStandalone,\n  standalone: boolean,\n): _content is ISerialisedEmbeddedFileStandalone {\n  return standalone\n}\n\nexport function fromJSON(\n  id: ID,\n  content: ISerialisedEmbeddedFileServer | ISerialisedEmbeddedFileStandalone,\n  standalone = false,\n): EmbeddedFile {\n  if (isStandalone(content, standalone)) {\n    return new EmbeddedFile({\n      id: generateInstantId(),\n      description: content.fileDescription,\n      attachmentId: id,\n      fileName: content.fileName || null,\n      fileSize: content.fileSize || null,\n      updatedAt: content.modificationDate ? new Date(content.modificationDate) : null,\n    })\n  }\n\n  return new EmbeddedFile({\n    id,\n    description: content.description,\n    attachmentId: content.fileAttachmentId,\n    fileName: content.fileName || null,\n    fileSize: content.fileSize || null,\n    updatedAt: new Date(content.updatedAt) || null,\n  })\n}\n","export function addBlobToWeakMap(\n  blobWeakMap: WeakMap<File | Blob, string>,\n  operationsDocuments: any,\n  blob: File | Blob,\n  operation: any,\n  index: number,\n  field: string,\n) {\n  let documentIndex\n\n  // Has this blob been already appended?\n  if (blobWeakMap.has(blob)) {\n    // Get the index of the blob\n    documentIndex = blobWeakMap.get(blob)\n  } else {\n    documentIndex = index.toString()\n    // Add the blob to the form payload\n    operationsDocuments[documentIndex] = blob\n    // Track the blob\n    blobWeakMap.set(blob, documentIndex)\n  }\n\n  return { ...operation, [field]: documentIndex }\n}\n","import { JSONToRect } from '@/lib/serializers/rect'\nimport { List } from 'immutable'\nimport { invariant } from '@pspdfkit/shared'\nimport SearchResult from '../models/search/SearchResult'\n\nexport function parseJsonSearchResults(json: Array<Record<string, any>>): List<SearchResult> {\n  invariant(Array.isArray(json), 'Wrong `json` field')\n\n  return List(\n    json\n      .map(rawResult => {\n        invariant(typeof rawResult.pageIndex === 'number', 'Wrong `pageIndex` field')\n        invariant(typeof rawResult.previewText === 'string', 'Wrong `previewText` field')\n        invariant(Array.isArray(rawResult.rangeInPreview), 'Wrong `rangeInPreview` field')\n        invariant(Array.isArray(rawResult.rectsOnPage), 'Wrong `rectsOnPage` field')\n\n        return new SearchResult({\n          pageIndex: rawResult.pageIndex,\n          previewText: rawResult.previewText,\n          locationInPreview: rawResult.rangeInPreview[0],\n          lengthInPreview: rawResult.rangeInPreview[1],\n          rectsOnPage: List(rawResult.rectsOnPage).map(jsonRect =>\n            JSONToRect(jsonRect as [number, number, number, number]),\n          ),\n          isAnnotation: !!rawResult.isAnnotation,\n          annotationRect: rawResult.annotationRect ? JSONToRect(rawResult.annotationRect) : null,\n        })\n      })\n      .filter(Boolean),\n  )\n}\n"],"names":["SharedBackend","Map","annotation","blob","width","height","provider","this","invariant","constructor","formField","WidgetAnnotation","_readStateCallbacks","getFormFieldByName","formFieldName","formFieldValue","SignatureFormField","FormFieldValue","name","value","formattedValue","values","isCacheableAnnotationAPStream","renderAnnotation","cancelled","cancelPromise","promise","Promise","resolve","reject","cleanResolve","imageHandle","annotationAPStreamPromiseResolve","annotationAPStreamPromises","get","id","delete","set","pageAPStreamsPromise","pageAPStreamsPromises","pageIndex","annotationAPStreamPromise","cachedPageAPStreams","cachedAPStreams","cachedAPStream","cancel","cacheAPStream","setIn","forEach","APStream","release","annotationIds","filter","_APStream","annotationId","has","updateIn","functionThatReturnsTrue","RequestQueue","inflightRequestLimit","queue","OrderedMap","priorityQueue","inFlightRequests","isDestroyed","request","hasPriority","resolveFn","rejectFn","targetQueue","newQueue","next","setTimeout","_cancel","response","promiseTuple","error","size","lastEntry","findLastEntry","then","_requestFinished","catch","_requestFailed","findEntry","EmbeddedFile","Immutable","attachmentId","description","fileName","fileSize","updatedAt","isStandalone","_content","standalone","fromJSON","content","generateInstantId","fileDescription","modificationDate","Date","fileAttachmentId","addBlobToWeakMap","blobWeakMap","operationsDocuments","operation","index","field","documentIndex","toString","parseJsonSearchResults","json","Array","isArray","List","map","rawResult","previewText","rangeInPreview","rectsOnPage","SearchResult","locationInPreview","lengthInPreview","jsonRect","JSONToRect","isAnnotation","annotationRect","Boolean"],"sourceRoot":""}