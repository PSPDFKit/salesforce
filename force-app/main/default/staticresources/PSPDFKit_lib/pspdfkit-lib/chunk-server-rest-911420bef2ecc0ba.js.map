{"version":3,"file":"pspdfkit-lib/chunk-server-rest-911420bef2ecc0ba.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/RESTProvider/RESTProviderState.ts","webpack://PSPDFKit/./src/lib/RESTProvider/RESTProvider.ts"],"sourcesContent":["import { List, Map } from 'immutable'\nimport * as Immutable from 'immutable'\n\ninterface IRESTProviderState {\n  alreadyLoadedPages: Map<number, Promise<void>>\n  serverURL: string | null\n  authPayload: {\n    token: string\n  } | null\n  isLoaded: boolean\n  isFormsEnabled: boolean\n  loadBookmarksPromise: Promise<void> | null | undefined\n  ignoredFormFieldNames?: List<string> | null\n}\n\nexport class RESTProviderState extends Immutable.Record<IRESTProviderState>({\n  alreadyLoadedPages: Map(),\n  serverURL: null,\n  authPayload: null,\n  isLoaded: false,\n  isFormsEnabled: true,\n  loadBookmarksPromise: null,\n  ignoredFormFieldNames: null,\n}) {\n  /**\n   * Used to remember which page annotations have already been loaded.\n   *\n   * @member {Immutable.Map.<number, Promise.<void>>} alreadyLoadedPages\n   */\n  override alreadyLoadedPages: Map<number, Promise<void>>\n\n  /**\n   * @member {string} serverURL\n   */\n  override serverURL: string\n\n  /**\n   * @member {Object} authPayload\n   */\n  override authPayload: {\n    token: string\n  }\n  override isLoaded: boolean\n  override isFormsEnabled: boolean\n\n  /**\n   * Used to fire loadBookmarks only once.\n   *\n   * @member {?Promise.<void>} loadBookmarksPromise\n   */\n  override loadBookmarksPromise: Promise<void> | null | undefined\n\n  /**\n   * Used to know which form field values can be omitted safely.\n   *\n   * @member {?List.<string>} ignoredFormFieldNames\n   */\n  override ignoredFormFieldNames?: List<string>\n}\n","import { List, Map } from 'immutable'\nimport { info, PSPDFKitError, error, invariant } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  serializeAnnotation,\n  serializeFormFieldValue,\n} from '../serializers/utils'\nimport {\n  fromJSON as deserializeBookmark,\n  toJSON as serializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { RESTProviderState } from './RESTProviderState'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { CREATE_REASON_LOAD } from '../Provider'\nimport { getVersionHeader } from '@/utils/environment'\n\nimport type { Annotation, Attachment, Bookmark, FormFieldValue } from '@/models'\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as BookmarkID } from '@/models/Bookmark'\nimport type { IObject } from '@/typings/utils'\n\n/**\n * A REST interface to annotation loading. It can't handle real time update and will fetch\n * annotations per-page.\n *\n * @todo How do we handle errors?\n */\nexport class RESTProvider\n  implements ReadStateProvider, AnnotationProvider, BookmarkProvider, FormFieldValueProvider\n{\n  _readStateCallbacks: ReadStateProviderCallbacks | null | undefined\n  _setReadStateCallbacksPromiseResolve: (() => void) | null\n  _setReadStateCallbacksPromise: Promise<void>\n  annotationCallbacks: AnnotationProviderCallbacks | null | undefined\n  bookmarkCallbacks: BookmarkProviderCallbacks | null | undefined\n  formFieldValueCallbacks: FormFieldValueCallbacks | null | undefined\n  state: RESTProviderState\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    authPayload: {\n      token: string\n    },\n    {\n      isFormsEnabled,\n    }: {\n      isFormsEnabled: boolean\n    },\n  ) {\n    this.state = new RESTProviderState({\n      serverURL,\n      authPayload,\n      isFormsEnabled,\n    })\n\n    this._setReadStateCallbacksPromise = new Promise(resolve => {\n      this._setReadStateCallbacksPromiseResolve = resolve\n    })\n  }\n\n  /*************************\n   * Connection management *\n   *************************/\n  async load(): Promise<RESTProvider> {\n    this.state = this.state.set('isLoaded', true)\n\n    if (this.state.isFormsEnabled) {\n      // Form Field Values are not loaded on a per-page basis. Thus, we fetch them all in here\n      await this._initializeFormFieldValues()\n    }\n\n    return this\n  }\n\n  destroy(): void {}\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n\n    this._setReadStateCallbacksPromiseResolve?.()\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this.annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this.bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this.formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  /******************\n   * Annotation API *\n   ******************/\n  async createAnnotation(\n    annotation: Annotation,\n    attachments: Map<string, Attachment>,\n  ): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n    const annotationBody = {\n      id,\n      content,\n    }\n\n    await this._request('/annotations', 'POST', annotationBody).then(r => {\n      if (r.status !== 200) {\n        throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an annotation.')\n      }\n\n      r.json().then(json => {\n        if (json.error === 'attachment_missing') {\n          // When the attachment is not already stored on the server, we need to attach the\n          // attachments to the request\n          const newBody = createFormData(annotationBody, attachments)\n\n          return this._request('/annotations', 'POST', newBody).then(r => r.json())\n        }\n\n        return json\n      })\n    })\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n\n    await this._request(`/annotations/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    await this._request(`/annotations/${annotation.id}`, 'DELETE')\n  }\n\n  /******************\n   * Bookmark API *\n   ******************/\n  async createBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n    const response = await this._request('/bookmarks', 'POST', {\n      id,\n      content,\n    })\n\n    if (response.status !== 200) {\n      throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an bookmark.')\n    }\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    await this._request(`/bookmarks/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n    await this._request(`/bookmarks/${bookmarkId}`, 'DELETE')\n  }\n\n  /******************\n   * FormFieldValue API *\n   ******************/\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    this._verifyLoaded()\n\n    const payload = {\n      id: getFormFieldValueID(formFieldValue),\n      content: serializeFormFieldValue(formFieldValue),\n    }\n\n    await this._request('/form-field-values', 'POST', {\n      formFieldValues: [payload],\n    })\n  }\n\n  // Stub to be implemented when this provider is supported\n  async createFormFieldValue(): Promise<void> {\n    return\n  }\n\n  // Stub to be implemented when this provider is supported\n  async deleteFormFieldValue(): Promise<void> {\n    return\n  }\n\n  async loadAnnotationsForPageIndex(pageIndex: number): Promise<void> {\n    this._verifyLoaded()\n\n    if (this.state.alreadyLoadedPages.has(pageIndex)) {\n      await this.state.alreadyLoadedPages.get(pageIndex)\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request(`/page-${pageIndex}-annotations`, 'GET')\n        .then(response => response.json())\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadAnnotationsForPageIndex` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], Promise.resolve())\n\n      const additions = List().withMutations(mutableAdditions => {\n        payload.annotations.forEach(record => {\n          try {\n            mutableAdditions.push(deserializeAnnotation(record.id, record.content))\n          } catch (error) {\n            info(\n              `Skipped creating annotation #${record.id} from payload because an error occurred while deserializing.`,\n              record.content,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (additions.size > 0) {\n        invariant(this.annotationCallbacks)\n        this.annotationCallbacks.createAnnotations(additions, Map(), CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'annotations')\n    }\n  }\n\n  async loadBookmarks() {\n    this._verifyLoaded()\n\n    if (this.state.loadBookmarksPromise) {\n      await this.state.loadBookmarksPromise\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request('/bookmarks', 'GET')\n        .then(response => response.json())\n        .then(payload => payload.data)\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadBookmarks` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.set('loadBookmarksPromise', payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.set('loadBookmarksPromise', Promise.resolve())\n      invariant(Array.isArray(payload.bookmarks), 'Unexpected reply from bookmarks endpoint.')\n\n      const bookmarks = List().withMutations(mutableBookmarks => {\n        payload.bookmarks.forEach((json: Record<string, any>) => {\n          try {\n            mutableBookmarks.push(deserializeBookmark(json.id, json.content))\n          } catch (error) {\n            info(\n              `Skipped creating bookmark #${json.id} from payload because an error occurred while deserializing.`,\n              // @ts-expect-error\n              json,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (bookmarks.size > 0) {\n        invariant(this.bookmarkCallbacks)\n        this.bookmarkCallbacks.createBookmarks(bookmarks, CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'bookmarks')\n    }\n  }\n\n  async syncChanges(): Promise<void> {}\n\n  async _initializeFormFieldValues(): Promise<void> {\n    const request = await this._request('/form-field-values', 'GET')\n    const response = await request.json()\n\n    invariant(\n      Array.isArray(response.formFieldValues),\n      'Unexpected reply from form-values endpoint.',\n    )\n\n    const formFieldValues = List<FormFieldValue>(\n      response.formFieldValues\n        .map(({ content: formFieldValueJSON }) => {\n          try {\n            return deserializeFormFieldValue(formFieldValueJSON)\n          } catch (error) {\n            info(\n              `Skipped form field value ${formFieldValueJSON.name} from payload because an error occurred while deserializing.`,\n              formFieldValueJSON,\n            )\n            info(error)\n\n            return null\n          }\n        })\n        .filter(Boolean),\n    )\n\n    invariant(this.formFieldValueCallbacks)\n\n    if (this.state.ignoredFormFieldNames && this.state.ignoredFormFieldNames.size) {\n      this.formFieldValueCallbacks.setFormFieldValues(\n        formFieldValues.filter(value => !this.state.ignoredFormFieldNames?.includes(value.name)),\n      )\n    } else {\n      this.formFieldValueCallbacks.setFormFieldValues(formFieldValues)\n    }\n  }\n\n  _handleError(e: Error, type: 'annotations' | 'bookmarks') {\n    error(`Loading or updating ${type} failed:\n\n${e.message}`)\n  }\n\n  _request(\n    path: string,\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    body?: IObject,\n  ): Promise<IObject> {\n    invariant(this.state.authPayload != null, 'Cannot call request without authPayload')\n\n    const contentTypeHeader =\n      !(body instanceof FormData) && typeof body === 'object'\n        ? {\n            'Content-Type': 'application/json',\n          }\n        : null\n    const headers = {\n      'X-PSPDFKit-Token': this.state.authPayload.token,\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': getVersionHeader(),\n      ...contentTypeHeader,\n    }\n\n    return fetch(`${this.state.serverURL}${path}`, {\n      method,\n      headers,\n      body:\n        body instanceof FormData\n          ? body\n          : typeof body === 'object'\n          ? JSON.stringify(body)\n          : undefined,\n      credentials: 'include',\n    })\n  }\n\n  _verifyLoaded() {\n    if (!this.state.isLoaded) {\n      throw new Error('not loaded')\n    }\n  }\n\n  setDocumentHandleConflictCallback = () => {}\n\n  setIgnoredFormFieldNames(formFields: List<string>) {\n    this.state = this.state.set('ignoredFormFieldNames', formFields)\n  }\n}\n\nfunction createFormData(annotationBody, attachments) {\n  const formData = new FormData()\n\n  formData.append('annotation', JSON.stringify(annotationBody))\n  attachments.forEach((attachment, attachmentId) => {\n    if (attachmentId && attachment.data) {\n      formData.append(attachmentId, attachment.data)\n    }\n  })\n\n  return formData\n}\n"],"names":["RESTProviderState","Immutable","alreadyLoadedPages","Map","serverURL","authPayload","isLoaded","isFormsEnabled","loadBookmarksPromise","ignoredFormFieldNames","RESTProvider","this","state","_setReadStateCallbacksPromise","Promise","resolve","_setReadStateCallbacksPromiseResolve","set","_initializeFormFieldValues","readStateCallbacks","_readStateCallbacks","annotationCallbacks","bookmarkCallbacks","formFieldValueCallbacks","annotation","attachments","_verifyLoaded","serializeAnnotation","id","content","annotationBody","_request","then","r","status","PSPDFKitError","json","error","newBody","createFormData","bookmark","loadBookmarks","serializeBookmark","bookmarkId","formFieldValue","payload","getFormFieldValueID","serializeFormFieldValue","formFieldValues","pageIndex","has","get","payloadPromise","response","catch","setIn","additions","List","withMutations","mutableAdditions","annotations","forEach","record","push","deserializeAnnotation","info","size","invariant","createAnnotations","CREATE_REASON_LOAD","_handleError","data","Array","isArray","bookmarks","mutableBookmarks","deserializeBookmark","createBookmarks","request","map","formFieldValueJSON","deserializeFormFieldValue","name","filter","Boolean","setFormFieldValues","value","includes","e","type","message","path","method","body","contentTypeHeader","FormData","headers","token","getVersionHeader","fetch","JSON","stringify","undefined","credentials","Error","formFields","formData","append","attachment","attachmentId"],"sourceRoot":""}