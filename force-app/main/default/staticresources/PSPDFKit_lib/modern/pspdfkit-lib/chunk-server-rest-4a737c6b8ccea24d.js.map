{"version":3,"file":"modern/pspdfkit-lib/chunk-server-rest-4a737c6b8ccea24d.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/RESTProvider/RESTProviderState.ts","webpack://PSPDFKit/./src/lib/RESTProvider/RESTProvider.ts"],"sourcesContent":["import { List, Map } from 'immutable'\nimport * as Immutable from 'immutable'\n\ninterface IRESTProviderState {\n  alreadyLoadedPages: Map<number, Promise<void>>\n  serverURL: string | null\n  authPayload: {\n    token: string\n  } | null\n  isLoaded: boolean\n  isFormsEnabled: boolean\n  loadBookmarksPromise: Promise<void> | null | undefined\n  ignoredFormFieldNames?: List<string> | null\n}\n\nexport class RESTProviderState extends Immutable.Record<IRESTProviderState>({\n  alreadyLoadedPages: Map(),\n  serverURL: null,\n  authPayload: null,\n  isLoaded: false,\n  isFormsEnabled: true,\n  loadBookmarksPromise: null,\n  ignoredFormFieldNames: null,\n}) {\n  /**\n   * Used to remember which page annotations have already been loaded.\n   *\n   * @member {Immutable.Map.<number, Promise.<void>>} alreadyLoadedPages\n   */\n  override alreadyLoadedPages: Map<number, Promise<void>>\n\n  /**\n   * @member {string} serverURL\n   */\n  override serverURL: string\n\n  /**\n   * @member {Object} authPayload\n   */\n  override authPayload: {\n    token: string\n  }\n  override isLoaded: boolean\n  override isFormsEnabled: boolean\n\n  /**\n   * Used to fire loadBookmarks only once.\n   *\n   * @member {?Promise.<void>} loadBookmarksPromise\n   */\n  override loadBookmarksPromise: Promise<void> | null | undefined\n\n  /**\n   * Used to know which form field values can be omitted safely.\n   *\n   * @member {?List.<string>} ignoredFormFieldNames\n   */\n  override ignoredFormFieldNames?: List<string>\n}\n","import { List, Map } from 'immutable'\nimport { info, PSPDFKitError, error, invariant } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  serializeAnnotation,\n  serializeFormFieldValue,\n} from '../serializers/utils'\nimport {\n  fromJSON as deserializeBookmark,\n  toJSON as serializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { RESTProviderState } from './RESTProviderState'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { CREATE_REASON_LOAD } from '../Provider'\nimport { getVersionHeader } from '@/utils/environment'\n\nimport type { Annotation, Attachment, Bookmark, FormFieldValue } from '@/models'\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as BookmarkID } from '@/models/Bookmark'\nimport type { IObject } from '@/typings/utils'\n\n/**\n * A REST interface to annotation loading. It can't handle real time update and will fetch\n * annotations per-page.\n *\n * @todo How do we handle errors?\n */\nexport class RESTProvider\n  implements ReadStateProvider, AnnotationProvider, BookmarkProvider, FormFieldValueProvider\n{\n  _readStateCallbacks: ReadStateProviderCallbacks | null | undefined\n  _setReadStateCallbacksPromiseResolve: (() => void) | null\n  _setReadStateCallbacksPromise: Promise<void>\n  annotationCallbacks: AnnotationProviderCallbacks | null | undefined\n  bookmarkCallbacks: BookmarkProviderCallbacks | null | undefined\n  formFieldValueCallbacks: FormFieldValueCallbacks | null | undefined\n  state: RESTProviderState\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    authPayload: {\n      token: string\n    },\n    {\n      isFormsEnabled,\n    }: {\n      isFormsEnabled: boolean\n    },\n  ) {\n    this.state = new RESTProviderState({\n      serverURL,\n      authPayload,\n      isFormsEnabled,\n    })\n\n    this._setReadStateCallbacksPromise = new Promise(resolve => {\n      this._setReadStateCallbacksPromiseResolve = resolve\n    })\n  }\n\n  /*************************\n   * Connection management *\n   *************************/\n  async load(): Promise<RESTProvider> {\n    this.state = this.state.set('isLoaded', true)\n\n    if (this.state.isFormsEnabled) {\n      // Form Field Values are not loaded on a per-page basis. Thus, we fetch them all in here\n      await this._initializeFormFieldValues()\n    }\n\n    return this\n  }\n\n  destroy(): void {}\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n\n    this._setReadStateCallbacksPromiseResolve?.()\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this.annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this.bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this.formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  /******************\n   * Annotation API *\n   ******************/\n  async createAnnotation(\n    annotation: Annotation,\n    attachments: Map<string, Attachment>,\n  ): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n    const annotationBody = {\n      id,\n      content,\n    }\n\n    await this._request('/annotations', 'POST', annotationBody).then(r => {\n      if (r.status !== 200) {\n        throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an annotation.')\n      }\n\n      r.json().then(json => {\n        if (json.error === 'attachment_missing') {\n          // When the attachment is not already stored on the server, we need to attach the\n          // attachments to the request\n          const newBody = createFormData(annotationBody, attachments)\n\n          return this._request('/annotations', 'POST', newBody).then(r => r.json())\n        }\n\n        return json\n      })\n    })\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeAnnotation(annotation)\n\n    await this._request(`/annotations/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteAnnotation(annotation: Annotation): Promise<void> {\n    this._verifyLoaded()\n\n    await this._request(`/annotations/${annotation.id}`, 'DELETE')\n  }\n\n  /******************\n   * Bookmark API *\n   ******************/\n  async createBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n    const response = await this._request('/bookmarks', 'POST', {\n      id,\n      content,\n    })\n\n    if (response.status !== 200) {\n      throw new PSPDFKitError('PSPDFKit Server returned an error, when saving an bookmark.')\n    }\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n\n    // We delete id from content so the server doesn't persist the ID in the content.\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    await this._request(`/bookmarks/${id}`, 'PUT', {\n      id,\n      content,\n    })\n  }\n\n  async deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    this._verifyLoaded()\n\n    // Make sure bookmarks are loaded.\n    await this.loadBookmarks()\n    await this._request(`/bookmarks/${bookmarkId}`, 'DELETE')\n  }\n\n  /******************\n   * FormFieldValue API *\n   ******************/\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    this._verifyLoaded()\n\n    const payload = {\n      id: getFormFieldValueID(formFieldValue),\n      content: serializeFormFieldValue(formFieldValue),\n    }\n\n    await this._request('/form-field-values', 'POST', {\n      formFieldValues: [payload],\n    })\n  }\n\n  // Stub to be implemented when this provider is supported\n  async createFormFieldValue(): Promise<void> {\n    return\n  }\n\n  // Stub to be implemented when this provider is supported\n  async deleteFormFieldValue(): Promise<void> {\n    return\n  }\n\n  async loadAnnotationsForPageIndex(pageIndex: number): Promise<void> {\n    this._verifyLoaded()\n\n    if (this.state.alreadyLoadedPages.has(pageIndex)) {\n      await this.state.alreadyLoadedPages.get(pageIndex)\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request(`/page-${pageIndex}-annotations`, 'GET')\n        .then(response => response.json())\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadAnnotationsForPageIndex` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.setIn(['alreadyLoadedPages', pageIndex], Promise.resolve())\n\n      const additions = List().withMutations(mutableAdditions => {\n        payload.annotations.forEach(record => {\n          try {\n            mutableAdditions.push(deserializeAnnotation(record.id, record.content))\n          } catch (error) {\n            info(\n              `Skipped creating annotation #${record.id} from payload because an error occurred while deserializing.`,\n              record.content,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (additions.size > 0) {\n        invariant(this.annotationCallbacks)\n        this.annotationCallbacks.createAnnotations(additions, Map(), CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'annotations')\n    }\n  }\n\n  async loadBookmarks() {\n    this._verifyLoaded()\n\n    if (this.state.loadBookmarksPromise) {\n      await this.state.loadBookmarksPromise\n\n      return\n    }\n\n    try {\n      const payloadPromise = this._request('/bookmarks', 'GET')\n        .then(response => response.json())\n        .then(payload => payload.data)\n        .catch(error => {\n          throw error\n        })\n\n      // We save the promise so that if `loadBookmarks` is called again\n      // before the promise resolves the new calls awaits for the promise as well!\n      this.state = this.state.set('loadBookmarksPromise', payloadPromise)\n\n      const payload = await payloadPromise\n\n      // At this point we don't need a reference to the original promise anymore.\n      this.state = this.state.set('loadBookmarksPromise', Promise.resolve())\n      invariant(Array.isArray(payload.bookmarks), 'Unexpected reply from bookmarks endpoint.')\n\n      const bookmarks = List().withMutations(mutableBookmarks => {\n        payload.bookmarks.forEach((json: Record<string, any>) => {\n          try {\n            mutableBookmarks.push(deserializeBookmark(json.id, json.content))\n          } catch (error) {\n            info(\n              `Skipped creating bookmark #${json.id} from payload because an error occurred while deserializing.`,\n              // @ts-expect-error\n              json,\n            )\n            info(error)\n          }\n        })\n      })\n\n      if (bookmarks.size > 0) {\n        invariant(this.bookmarkCallbacks)\n        this.bookmarkCallbacks.createBookmarks(bookmarks, CREATE_REASON_LOAD)\n      }\n    } catch (error) {\n      this._handleError(error, 'bookmarks')\n    }\n  }\n\n  async syncChanges(): Promise<void> {}\n\n  async _initializeFormFieldValues(): Promise<void> {\n    const request = await this._request('/form-field-values', 'GET')\n    const response = await request.json()\n\n    invariant(\n      Array.isArray(response.formFieldValues),\n      'Unexpected reply from form-values endpoint.',\n    )\n\n    const formFieldValues = List<FormFieldValue>(\n      response.formFieldValues\n        .map(({ content: formFieldValueJSON }) => {\n          try {\n            return deserializeFormFieldValue(formFieldValueJSON)\n          } catch (error) {\n            info(\n              `Skipped form field value ${formFieldValueJSON.name} from payload because an error occurred while deserializing.`,\n              formFieldValueJSON,\n            )\n            info(error)\n\n            return null\n          }\n        })\n        .filter(Boolean),\n    )\n\n    invariant(this.formFieldValueCallbacks)\n\n    if (this.state.ignoredFormFieldNames && this.state.ignoredFormFieldNames.size) {\n      this.formFieldValueCallbacks.setFormFieldValues(\n        formFieldValues.filter(value => !this.state.ignoredFormFieldNames?.includes(value.name)),\n      )\n    } else {\n      this.formFieldValueCallbacks.setFormFieldValues(formFieldValues)\n    }\n  }\n\n  _handleError(e: Error, type: 'annotations' | 'bookmarks') {\n    error(`Loading or updating ${type} failed:\n\n${e.message}`)\n  }\n\n  _request(\n    path: string,\n    method: 'GET' | 'POST' | 'PUT' | 'DELETE',\n    body?: IObject,\n  ): Promise<IObject> {\n    invariant(this.state.authPayload != null, 'Cannot call request without authPayload')\n\n    const contentTypeHeader =\n      !(body instanceof FormData) && typeof body === 'object'\n        ? {\n            'Content-Type': 'application/json',\n          }\n        : null\n    const headers = {\n      'X-PSPDFKit-Token': this.state.authPayload.token,\n      'PSPDFKit-Platform': 'web',\n      'PSPDFKit-Version': getVersionHeader(),\n      ...contentTypeHeader,\n    }\n\n    return fetch(`${this.state.serverURL}${path}`, {\n      method,\n      headers,\n      body:\n        body instanceof FormData\n          ? body\n          : typeof body === 'object'\n          ? JSON.stringify(body)\n          : undefined,\n      credentials: 'include',\n    })\n  }\n\n  _verifyLoaded() {\n    if (!this.state.isLoaded) {\n      throw new Error('not loaded')\n    }\n  }\n\n  setDocumentHandleConflictCallback = () => {}\n\n  setIgnoredFormFieldNames(formFields: List<string>) {\n    this.state = this.state.set('ignoredFormFieldNames', formFields)\n  }\n}\n\nfunction createFormData(annotationBody, attachments) {\n  const formData = new FormData()\n\n  formData.append('annotation', JSON.stringify(annotationBody))\n  attachments.forEach((attachment, attachmentId) => {\n    if (attachmentId && attachment.data) {\n      formData.append(attachmentId, attachment.data)\n    }\n  })\n\n  return formData\n}\n"],"names":["RESTProviderState","Immutable","alreadyLoadedPages","Map","serverURL","authPayload","isLoaded","isFormsEnabled","loadBookmarksPromise","ignoredFormFieldNames","RESTProvider","canCreateBackendOrphanWidgets","constructor","this","state","_setReadStateCallbacksPromise","Promise","resolve","_setReadStateCallbacksPromiseResolve","set","_initializeFormFieldValues","destroy","setReadStateCallbacks","readStateCallbacks","_readStateCallbacks","setAnnotationCallbacks","annotationCallbacks","setBookmarkCallbacks","bookmarkCallbacks","setFormFieldValueCallbacks","formFieldValueCallbacks","annotation","attachments","_verifyLoaded","id","content","serializeAnnotation","annotationBody","_request","then","r","status","PSPDFKitError","json","error","newBody","formData","FormData","append","JSON","stringify","forEach","attachment","attachmentId","data","createFormData","bookmark","loadBookmarks","serializeBookmark","bookmarkId","formFieldValue","payload","getFormFieldValueID","serializeFormFieldValue","formFieldValues","pageIndex","has","get","payloadPromise","response","catch","setIn","additions","List","withMutations","mutableAdditions","annotations","record","push","deserializeAnnotation","info","size","invariant","createAnnotations","CREATE_REASON_LOAD","_handleError","Array","isArray","bookmarks","mutableBookmarks","deserializeBookmark","createBookmarks","request","map","formFieldValueJSON","deserializeFormFieldValue","name","filter","Boolean","setFormFieldValues","value","includes","e","type","message","path","method","body","contentTypeHeader","headers","token","getVersionHeader","fetch","undefined","credentials","Error","setDocumentHandleConflictCallback","setIgnoredFormFieldNames","formFields"],"sourceRoot":""}