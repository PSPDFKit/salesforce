{"version":3,"file":"modern/pspdfkit-lib/chunk-server-instant-8281686b1ef21c1f.js","mappings":"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","sources":["webpack://PSPDFKit/./src/lib/ClientsPresence/models/Client.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/models/ClientsPresenceState.ts","webpack://PSPDFKit/./src/lib/Timer.ts","webpack://PSPDFKit/./src/lib/WebsocketConnection/WebsocketConnection.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/utils/clients.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/ClientsPresence.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/setClientsAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/applyClientChangesAction.ts","webpack://PSPDFKit/./src/lib/ClientsPresence/actions/updateCurrentClientPresenceAction.ts","webpack://PSPDFKit/./src/lib/InstantProvider/RecordChangeRequest.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSyncState.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantSync.ts","webpack://PSPDFKit/./src/lib/InstantProvider/collaboration-permissions.ts","webpack://PSPDFKit/./src/lib/InstantProvider/InstantProvider.ts"],"sourcesContent":["import * as Immutable from 'immutable'\n\ninterface IClient {\n  clientId: string\n  userId: string | null\n  presenceContent: Record<string, unknown>\n}\n\nexport default class Client extends Immutable.Record<IClient>({\n  clientId: '',\n  userId: null,\n  presenceContent: {},\n}) {\n  /**\n   * Holds the client ID as a string. A unique ID is generated for every client.\n   *\n   * @member {string} clientId\n   */\n  override clientId: string\n\n  /**\n   * Holds the user ID of the client. This ID is supplied by your backend. If the value is `null`,\n   * the client does not belong to a user and thus is considered anonymous.\n   *\n   * @member {?string} userId\n   */\n  override userId: string | null\n\n  /**\n   * Holds the latest presence content a client has announced. This can be an arbitrary object.\n   *\n   * @member {Object} presenceContent\n   */\n  override presenceContent: Record<string, any>\n}\n","import { Map } from 'immutable'\nimport type Client from './Client'\nimport * as Immutable from 'immutable'\n\ninterface IClientsPresenceState {\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   *\n   * @member {string} status\n   */\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: null | Client\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   *\n   * @member {Immutable.Map.<string, Client>} presence\n   */\n  clients: Map<string, Client>\n}\n\n/**\n * ClientsPresenceState\n *\n * Describes current state of ClientsPresence\n */\n\nexport default class ClientsPresenceState extends Immutable.Record<IClientsPresenceState>({\n  status: 'offline',\n  currentClient: null,\n  clients: Map(),\n}) {}\n","export default class Timer {\n  callback: () => void\n  timerCalc: (tries: number) => number\n  timer: NodeJS.Timeout | null\n  tries: number\n\n  constructor(callback: () => void, timerCalc: (tries: number) => number) {\n    this.callback = callback\n    this.timerCalc = timerCalc\n    this.timer = null\n    this.tries = 0\n  }\n\n  reset(): void {\n    this.tries = 0\n    this.timer && clearTimeout(this.timer)\n  }\n\n  // Cancels any previous scheduleTimeout and schedules callback\n  scheduleTimeout(): void {\n    this.timer && clearTimeout(this.timer)\n    this.timer = setTimeout(() => {\n      this.tries = this.tries + 1\n      this.callback()\n    }, this.timerCalc(this.tries + 1)) as unknown as NodeJS.Timeout\n  }\n}\n","import { getEnvironment } from '@/utils/environment'\nimport { Map } from 'immutable'\nimport EventEmitter from '../EventEmitter'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Timer from '../Timer'\nimport { invariant } from '@/utils/invariant'\nimport { IObject } from '@/typings/utils'\n\nconst CLIENT_VERSION = '0.0.1'\nconst PROTOCOL_VERSION = 2\nconst SOCKET_STATES = {\n  connecting: 0,\n  open: 1,\n  closing: 2,\n  closed: 3,\n}\nconst CLIENT_INFO = {\n  name: 'PSPDFKit-Web',\n}\n\nconst defaultReconnectTimerCalc = n => [1000, 2000][n - 1] || 5000\n/**\n * SYNCConnection\n *\n * Abstracts the web socket and the sync protocol. This class behaves like an event emitter, which\n * means that we can listen on any incoming message using the `.on('type', callback)` method.\n *\n * In case the connection gets interrupted, we try to reconnect in a specified time interval. The\n * next time a reconnect is successful, we will emit the `reconnect` event.\n *\n * A SYNCConnection will publish the following events:\n *   - `connect` when the connection was authenticated with the argument\n *     `{ userId: ?string, clientId: string }`. This will also be called when the connection was\n *     closed and we have successfully reconnected. In theory the same token could then be used to\n *     authenticated a different user.\n *   - `disconnect` when the connection was interrupted. Use this to show a disconnect message until\n *     we emit the `authenticated` action again.\n *   - `error` when we discover a non-recoverable error during the authentication flow. In this\n *     case, we will try to reconnect. This can happen when the auth token is invalid.\n *   - `record_changes` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *   - `client_presence` when the server sends the analogue info request. This will simply forward\n *     the same payload\n *\n * @private\n */\n\nexport default class WebsocketConnection {\n  eventEmitter: EventEmitter\n  serverURL: string\n  authPayload: IObject\n  socket: WebSocket | null\n  lastRequestId: number\n  requestsWaitingForAnswers: Map<\n    number,\n    {\n      resolve: (payload: IObject) => void\n      reject: (error: Error) => void\n    }\n  >\n  reconnectTimer: Timer | null\n  clientId: string\n  userId: string | null\n\n  constructor(\n    serverURL: string,\n    authPayload: IObject,\n    {\n      reconnectTimerCalc = defaultReconnectTimerCalc,\n      enableReconnect = true,\n      events = [],\n    }: {\n      reconnectTimerCalc?: (n: number) => number\n      enableReconnect?: boolean\n      events?: Array<string>\n    } = {},\n  ) {\n    this.eventEmitter = new EventEmitter(['connect', 'disconnect', 'error'].concat(events))\n    this.serverURL = serverURL\n    this.authPayload = authPayload\n    this.socket = null\n    this.lastRequestId = 0\n    this.requestsWaitingForAnswers = Map()\n\n    if (enableReconnect) {\n      this.reconnectTimer = new Timer(() => {\n        if (this.socket) {\n          this.socket.close()\n          this.socket = null\n        }\n\n        this.connect()\n      }, reconnectTimerCalc)\n    }\n\n    this.clearAuthenticationInformation()\n  }\n\n  registerEvents(events: Array<string>): void {\n    this.eventEmitter.events.push(...events)\n  }\n\n  connect() {\n    if (this.socket) {\n      return\n    }\n\n    const socket = new WebSocket(this.serverURL)\n\n    socket.onopen = this.onOpen.bind(this)\n    socket.onmessage = this.onMessage.bind(this)\n\n    socket.onerror = () => {\n      this.socket = null\n      this.eventEmitter.emit(\n        'error',\n        `Failed to create the WebSocket connection to ${this.serverURL}. ` +\n          'Please check your firewall or proxy settings.',\n      )\n    }\n\n    this.socket = socket\n  }\n\n  /**\n   * Closes the socket permanently. This will `.reject()` all outstanding request\n   */\n  disconnect(): void {\n    if (!this.socket) {\n      return\n    }\n\n    // unbind existing closing event so we don't try to reconnect\n    this.socket.onclose = () => {}\n\n    this.socket.close()\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.eventEmitter.emit('disconnect')\n  }\n\n  /**\n   * @returns {string} The current connection state. Either `connecting`, `open`, `closing`, or\n   *          `closed`\n   */\n  get connectionState(): 'connecting' | 'open' | 'closing' | 'closed' {\n    switch (this.socket && this.socket.readyState) {\n      case SOCKET_STATES.connecting:\n        return 'connecting'\n\n      case SOCKET_STATES.open:\n        return 'open'\n\n      case SOCKET_STATES.closing:\n        return 'closing'\n\n      default:\n        return 'closed'\n    }\n  }\n\n  /**\n   * @returns {boolean} true when the connection is authenticated\n   */\n  get isAuthenticated(): boolean {\n    return this.clientId !== ''\n  }\n\n  /**\n   * Sends data asynchronously to the server. This will generate a new request ID. Whenever the\n   * server responds, we will resolve the Promise.\n   *\n   * @param {string} action - The action you want to send\n   * @param {Object} payload - An arbitrary payload. This will be serialized as JSON\n   * @returns {Promise.<Object, PSPDFKitError>} A promise that will resolve as soon as the server responds to our request.\n   */\n  sendRequest(action: string, payload: IObject): Promise<IObject> {\n    return new Promise((resolve, reject) => {\n      if (!this.isAuthenticated || !this.socket) {\n        reject(new PSPDFKitError('Cannot send request when the connection is not authenticated'))\n\n        return\n      }\n\n      const requestId = this.nextRequestId()\n      const serializedPayload = JSON.stringify(payload)\n\n      this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.set(requestId, {\n        resolve,\n        reject,\n      })\n\n      const socket: WebSocket = this.socket\n\n      socket.send(`${requestId}:${action}:${serializedPayload}`)\n    })\n  }\n\n  // `on` and `off` will be forwarded to `this.eventEmitter`\n  on(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.on(action, callback)\n  }\n\n  off(\n    action: 'connect' | 'disconnect' | 'error' | string,\n    callback: (payload: IObject) => void,\n  ): void {\n    this.eventEmitter.off(action, callback)\n  }\n\n  /**\n   * Web socket callbacks\n   */\n\n  private onOpen() {\n    const socket = this.socket\n\n    if (socket) {\n      socket.onerror = this.onError.bind(this)\n      socket.onclose = this.onClose.bind(this)\n    }\n  }\n\n  private onMessage(message: MessageEvent) {\n    const data = message.data as string\n\n    if (this.isAuthenticated) {\n      const frame = this.parseFrame(data)\n\n      // Check whether this is a notification from the server or a response to a request\n      if (frame.requestId) {\n        const requestId = frame.requestId\n\n        invariant(\n          this.requestsWaitingForAnswers.has(requestId),\n          'Received a reply with an unknown request ID.',\n        )\n\n        const request = this.requestsWaitingForAnswers.get(requestId)\n\n        invariant(request)\n\n        switch (frame.action) {\n          case 'ok':\n            request.resolve(frame.payload)\n            break\n\n          case 'error':\n            request.reject(new PSPDFKitError(frame.payload.reason || 'Unknown error'))\n            break\n\n          default:\n            invariant(false, `${frame.action} is not a valid request reply`)\n        }\n\n        this.requestsWaitingForAnswers = this.requestsWaitingForAnswers.delete(requestId)\n      } else {\n        if (this.eventEmitter.events.includes(frame.action)) {\n          this.eventEmitter.emit(frame.action, frame.payload)\n        }\n\n        this.log('incoming info message', frame)\n      }\n    } else {\n      const frame = this.parseUnauthenticatedFrame(data)\n\n      // When the request is not yet authenticated, we only handle `hello` and `authenticated`\n      // messages\n      switch (frame.action) {\n        case 'hello':\n          this.onHello(frame.payload)\n          break\n\n        case 'authenticated':\n          this.onAuthenticated(frame.payload)\n          break\n\n        case 'error':\n          this.eventEmitter.emit('error', frame.payload.reason || 'Unknown error')\n      }\n    }\n  }\n\n  /**\n   * When the connection is closed, we will send the `disconnect` event so the client can display\n   * an adequate message. This will start our regular reconnection timer.\n   */\n  private onClose(event: CloseEvent) {\n    this.clearAuthenticationInformation()\n    this.abortOpenRequests()\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.eventEmitter.emit('disconnect')\n    this.log('close', event)\n  }\n\n  /**\n   * We will receive an error callback when there were problems opening the web socket. This will\n   * start our regular reconnection timer.\n   */\n  private onError(error: Event) {\n    this.reconnectTimer && this.reconnectTimer.scheduleTimeout()\n    this.log('error', error)\n  }\n\n  private nextRequestId(): number {\n    // We deliberately don't care about integer overflow of the request id. We will handle this in\n    // the future by reconnecting the client\n    const nextRequestId = this.lastRequestId + 1\n\n    this.lastRequestId = nextRequestId\n\n    return nextRequestId\n  }\n\n  private onHello(payload: IObject): void {\n    const socket: WebSocket = this.socket as any\n\n    if (payload.protocol_version === PROTOCOL_VERSION) {\n      const requestPayload = {\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n        auth_payload: this.authPayload,\n      }\n\n      socket.send(`hello_web:${JSON.stringify(requestPayload)}`)\n    } else {\n      const requestPayload = {\n        reason: 'protocol_mismatch',\n        protocol_version: PROTOCOL_VERSION,\n        client_version: CLIENT_VERSION,\n        client_info: CLIENT_INFO,\n      }\n\n      socket.send(`handshake_failed:${JSON.stringify(requestPayload)}`)\n      this.eventEmitter.emit('error', 'protocol_mismatch')\n    }\n  }\n\n  private onAuthenticated(payload: IObject): void {\n    invariant(payload.client_id, '`authenticated` message has no `client_id`')\n    this.clientId = payload.client_id\n    this.userId = payload.user_id || null\n    this.eventEmitter.emit('connect', {\n      clientId: this.clientId,\n      userId: this.userId,\n    })\n  }\n\n  private log(...args: Array<any>): void {\n    if (getEnvironment() === 'development') {\n      console.log('SYNCConnection', ...args) // eslint-disable-line no-console\n    }\n  }\n\n  /**\n   * When `requestId` in the response object is null, the frame is of type `info`.\n   */\n  private parseFrame(frame: string): {\n    requestId?: number | null\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(\\d+|info):([a-zA-Z-_]+):(.+)$/\n    const [, requestIdOrInfo, action, serializedPayload] = regex.exec(\n      frame.toString(),\n    ) as RegExpExecArray\n    let requestId: number | null = null\n\n    if (requestIdOrInfo !== 'info') {\n      requestId = parseInt(requestIdOrInfo)\n    }\n\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      requestId,\n      action,\n      payload,\n    }\n  }\n\n  private parseUnauthenticatedFrame(frame: string): {\n    action: string\n    payload: IObject\n  } {\n    const regex = /^(hello|authenticated|error):(.+)$/\n\n    const [, action, serializedPayload] = regex.exec(frame.toString()) as RegExpExecArray\n    const payload = JSON.parse(serializedPayload)\n\n    return {\n      action,\n      payload,\n    }\n  }\n\n  /** @private **/\n  abortOpenRequests(): void {\n    this.requestsWaitingForAnswers.forEach(request => {\n      request.reject(new PSPDFKitError('request aborted'))\n    })\n    this.requestsWaitingForAnswers = Map()\n  }\n\n  /** @private **/\n  clearAuthenticationInformation(): void {\n    this.clientId = ''\n    this.userId = null\n  }\n}\n","import { invariant } from '@pspdfkit/shared'\nimport Client from '../models/Client'\n\n/**\n * Used to map a payload entry for a client to a `Client`\n */\nexport function clientFromPayload(payload: Record<string, any>): Client {\n  invariant(typeof payload.client_id === 'string', 'The client payload must have a `client_id`')\n  invariant(typeof payload.presence === 'object', 'The client payload must have a `presence`')\n\n  return new Client({\n    clientId: payload.client_id,\n    userId: payload.user_id,\n    presenceContent: payload.presence,\n  })\n}\n","import { Class } from 'utility-types'\nimport { List, Map } from 'immutable'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport Client from './models/Client'\nimport ClientsPresenceState from './models/ClientsPresenceState'\nimport WebsocketConnection from '../WebsocketConnection/WebsocketConnection'\nimport setClientsAction from './actions/setClientsAction'\nimport applyClientChangesAction from './actions/applyClientChangesAction'\nimport updateCurrentClientPresenceAction from './actions/updateCurrentClientPresenceAction'\n\nexport default class ClientsPresence {\n  connection: WebsocketConnection\n  state: ClientsPresenceState\n  setState: (arg0: ClientsPresenceState) => void\n  connectionClass: Class<any>\n  clientUpdatesCallback: (\n    arg0: Map<string, Client>,\n    arg1: Map<string, Client>,\n    arg2: List<string>,\n  ) => void\n  shouldFireClientUpdatesCallback: boolean\n\n  /**\n   * For easier testing, we allow a custom state in the constructor.\n   */\n  constructor(\n    state: ClientsPresenceState = new ClientsPresenceState(),\n    connectionClass: Class<any> = WebsocketConnection,\n  ) {\n    this.state = state\n    this.connectionClass = connectionClass\n  }\n\n  /**\n   * This method should be called right after the constructor.\n   */\n  load(\n    serverURL: string,\n    authPayload: Record<string, any>,\n    initialPresenceContent: Record<string, any>,\n  ): Promise<ClientsPresence> {\n    return new Promise((resolve, reject) => {\n      this.setState = (newState: ClientsPresenceState): void => {\n        this.state = newState\n      }\n\n      this.connection = new this.connectionClass(serverURL, authPayload, {\n        events: ['client_presence'],\n      })\n      this.connection.on(\n        'connect',\n        // @ts-expect-error\n        (session: { clientId: string; userId?: string | null }) => {\n          const currentClient = new Client({\n            clientId: session.clientId,\n            userId: session.userId,\n            presenceContent: initialPresenceContent,\n          })\n\n          this.setState(this.state.set('status', 'online').set('currentClient', currentClient))\n          this.populateClients(initialPresenceContent)\n            .then(() => {\n              resolve(this)\n            })\n            .catch(reject)\n        },\n      )\n      this.connection.on('error', message => {\n        reject(new PSPDFKitError(message.toString()))\n      })\n      this.connection.on('client_presence', payload => this.onInfoClientPresence(payload))\n      this.connection.connect()\n    })\n  }\n\n  populateClients(presenceContent: Record<string, any>): Promise<any> {\n    return new Promise<void>((resolve, reject) => {\n      const enterZonePayload = {\n        presence: presenceContent,\n      }\n\n      this.connection\n        .sendRequest('enter_layer', enterZonePayload)\n        .then(payload => {\n          this.setState(setClientsAction(this.state, payload))\n          resolve()\n        })\n        .catch(reject)\n    })\n  }\n\n  onInfoClientPresence(payload: Record<string, any>): void {\n    this.setState(applyClientChangesAction(this.state, payload))\n\n    if (this.shouldFireClientUpdatesCallback) {\n      let entered: Map<string, Client> = Map()\n\n      if (payload.clients.entered) {\n        const enteredClientIds = payload.clients.entered.map(c => c.client_id)\n\n        entered = this.state.clients\n          .filter(client => {\n            return enteredClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let updated: Map<string, Client> = Map()\n\n      if (payload.clients.updated) {\n        const updatedClientIds = payload.clients.updated.map(c => c.client_id)\n\n        updated = this.state.clients\n          .filter(client => {\n            return updatedClientIds.indexOf(client.clientId) !== -1\n          })\n          .toMap()\n      }\n\n      let left = List()\n\n      if (payload.clients.updated) {\n        left = List(payload.clients.left)\n      }\n\n      this.clientUpdatesCallback(entered, updated, left)\n    }\n  }\n\n  /**\n   * Close the current connection and stop reconnecting attempts.\n   *\n   * @returns {void}\n   */\n  disconnect(): void {\n    if (this.getStatus() === 'offline') {\n      return\n    }\n\n    this.setState(this.state.set('status', 'offline'))\n    this.connection.disconnect()\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not.\n   *\n   * @returns {string} A status indicating the connection status, either `offline`, `connecting`, or\n   *         `online`.\n   */\n  getStatus(): 'offline' | 'connecting' | 'online' {\n    return this.state.status\n  }\n\n  /**\n   * Information about the currently connected client.\n   *\n   * @returns {Client} An object that holds information about the currently connected client.\n   */\n  getCurrentClient(): Client {\n    return this.state.currentClient as Client\n  }\n\n  /*********************\n   * Managing Presence *\n   *********************/\n\n  /**\n   * Returns a map of all connected clients of every user that is currently present in the zone.\n   *\n   * Before this method is called the first time, we will never fire a\n   * {@link ClientsPresence#onClientUpdates} callback. The reason for this is to give you time to set\n   * your callbacks, without missing out on information.\n   *\n   * @returns {Immutable.Map.<string, Client>} List of all connected clients form all users\n   */\n  getClients(): Map<string, Client> {\n    this.shouldFireClientUpdatesCallback = true\n\n    return this.state.clients\n  }\n\n  /**\n   * Updates the presence content for the zone of the current connection. The presence content is\n   * being broadcast to all other connected clients.\n   *\n   * When the server accepts our changes, we will resolve the `Promise` with `true`. In case of any\n   * error, we will reject with `PSPDFKitError`.\n   *\n   * @param {Object} presenceContent - An arbitrary object that describes the presence content.\n   * @returns {Promise.<boolean, PSPDFKitError>} A Promise that that will resolve with `true` or reject\n   *         with a `PSPDFKitError`.\n   */\n  updatePresence(presenceContent: Record<string, any>): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      if (this.getStatus() !== 'online') {\n        return reject(new PSPDFKitError('ClientsPresence is not connected'))\n      }\n\n      const payload = {\n        presence: presenceContent,\n      }\n\n      this.connection.sendRequest('update_client_presence', payload).then(\n        () => {\n          this.setState(updateCurrentClientPresenceAction(this.state, presenceContent))\n          resolve(true)\n        },\n        () => {\n          reject(new PSPDFKitError('Unable to update presence'))\n        },\n      )\n    })\n  }\n\n  /**********************\n   * Presence Callbacks *\n   **********************/\n\n  /**\n   * This callback will be triggered whenever the client map will be updated. It will contain\n   * the change set of entered, updated and left clients.\n   *\n   * It will not fire without you calling {@link ClientsPresence#getClients} before.\n   *\n   * @callback clientUpdatesCallback\n   * @param {Immutable.Map.<string, Client>} entered - A map of all clients that have entered\n   *        the zone\n   * @param {Immutable.Map.<string, Client>} updated - A map of all clients that published\n   *        presence updates.\n   * @param {Immutable.List.<string>} left - A list of all clients IDs that have disconnected from\n   *        this zone.\n   */\n\n  /**\n   * Sets a new clients update callback. When a callback is already set, it will overwrite the\n   * existing one (only one callback is registered to a ClientsPresence instance at any time).\n   *\n   * This callback should be registered before you call {@link ClientsPresence#getClients}. It will only\n   * fire after {@link ClientsPresence#getClients} is called the first times.\n   *\n   * The callback can never be set to `null` because otherwise your application could miss out on\n   * updates.\n   *\n   * @throws {TypeError} when the supplied `callback` is not a function\n   * @param {clientUpdatesCallback} callback - The callback that handles the clients map updates\n   */\n  onClientUpdates(\n    callback: (\n      entered: Map<string, Client>,\n      updated: Map<string, Client>,\n      left: List<string>,\n    ) => void,\n  ) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this.clientUpdatesCallback = callback\n  }\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { Map } from 'immutable'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\nimport Client from '../models/Client'\n\n/**\n * This action overwrites the current clients map with the `payload`. This is used, whenever we\n * `enter_layer`\n */\n\nexport default function setClientsAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(payload.clients, 'The payload must have a `clients` list')\n\n  return state.withMutations(mutableState => {\n    const clients = Map(\n      payload.clients\n        .map(clientPayload => clientFromPayload(clientPayload))\n        .map(c => [c.clientId, c]),\n    ).set(state.currentClient?.clientId, state.currentClient) as Map<string, Client>\n\n    mutableState.set('clients', clients)\n  })\n}\n","import { clientFromPayload } from '../utils/clients'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport type ClientsPresenceState from '../models/ClientsPresenceState'\nimport { invariant } from '../../../utils/invariant'\n\n/**\n * This action applies the change set from the `info:client_presence` message.\n *\n * @throws {PSPDFKitError} when we detect a failed state\n */\n\nexport default function applyClientChangesAction(\n  state: ClientsPresenceState,\n  payload: Record<string, any>,\n): ClientsPresenceState {\n  invariant(typeof payload.clients == 'object', 'The payload must have `clients`')\n\n  const newClients = state.clients.withMutations(mutableClients => {\n    if (payload.clients.entered) {\n      for (const clientPayload of payload.clients.entered) {\n        if (state.clients.has(clientPayload.client_id)) {\n          throw new PSPDFKitError('The client marked as entered is already known')\n        }\n\n        const client = clientFromPayload(clientPayload)\n\n        mutableClients.set(client.clientId, client)\n      }\n    }\n\n    // On updated clients, only the `presenceContent` can change\n    if (payload.clients.updated) {\n      for (const clientPayload of payload.clients.updated) {\n        invariant(\n          typeof clientPayload.client_id === 'string',\n          'The client payload must have a `client_id`',\n        )\n        invariant(\n          typeof clientPayload.presence === 'object',\n          'The client payload must have a `presence`',\n        )\n\n        const client = state.clients.get(clientPayload.client_id)\n\n        if (!client) {\n          throw new PSPDFKitError('The client marked as updated is not known')\n        }\n\n        mutableClients.set(client.clientId, client.set('presenceContent', clientPayload.presence))\n      }\n    }\n\n    if (payload.clients.left) {\n      for (const clientId of payload.clients.left) {\n        if (!state.clients.has(clientId)) {\n          throw new PSPDFKitError('The client marked as left is not known')\n        }\n\n        mutableClients.delete(clientId)\n      }\n    }\n  })\n\n  return state.set('clients', newClients)\n}\n","import type ClientsPresenceState from '../models/ClientsPresenceState'\n/**\n * This is used after a successful `update_client_presence` and will set the new `presenceContent`\n * inside the `currentClient` and the current client inside the `clients` map.\n */\n\nexport default function updateCurrentClientPresenceAction(\n  state: ClientsPresenceState,\n  presenceContent: Record<string, any>,\n): ClientsPresenceState {\n  return state\n    .setIn(['currentClient', 'presenceContent'], presenceContent)\n    .setIn(['clients', state.currentClient?.clientId, 'presenceContent'], presenceContent)\n}\n","import * as Immutable from 'immutable'\n\ninterface IRecordChangeRequest {\n  id: string | null\n  content?: Record<string, any> | null\n  attachments: Record<string, Blob> | null\n  group?: string\n  type: 'created' | 'updated' | 'deleted' | null\n  resolve: (response?: Record<string, any> | boolean | null) => void\n  reject: (error?: any) => void\n}\n\nexport default class RecordChangeRequest extends Immutable.Record<IRecordChangeRequest>({\n  content: null,\n  attachments: null,\n  id: null,\n  type: null,\n  group: undefined,\n  resolve: () => {},\n  reject: () => {},\n}) {\n  /**\n   * Holds the record ID as a string. This ID must follow the Instant spec.\n   *\n   * @member {string} id\n   */\n  override id: string\n\n  /**\n   * Holds the serialized record content.\n   *\n   * @member {?Object} content\n   */\n  override content?: Record<string, any>\n\n  /**\n   * Holds an Object where the annotations ids are mapped to the Blobs of the records attachments.\n   *\n   * @member {?Object} attachments\n   */\n  override attachments: Record<string, Blob>\n\n  /**\n   * Holds the group name of the record\n   *\n   * @type {string|void}\n   */\n  override group?: string\n\n  /**\n   * Changes can be `created` for new records, `updated` for existing\n   * records with a new content, or `deleted` for deleted records.\n   *\n   * @member {string} type\n   */\n  override type: 'created' | 'updated' | 'deleted'\n\n  /**\n   * Holds the `Promise#resolve` function for the change request\n   *\n   * @member {Function} resolve\n   */\n  override resolve: (response?: Record<string, any> | boolean | null) => void\n\n  /**\n   * Holds the `Promise#reject` function for the change request\n   *\n   * @member {Function} reject\n   */\n  override reject: (error?: any) => void\n}\n","import { List, Map, OrderedMap, Set } from 'immutable'\nimport type RecordChangeRequest from './RecordChangeRequest'\nimport type Client from '../ClientsPresence/models/Client'\nimport * as Immutable from 'immutable'\n\nexport type InstantSyncAuthPayload = {\n  auth_token: string\n}\n\ninterface IInstantSyncState {\n  requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  } | null\n  status: 'offline' | 'connecting' | 'online'\n  currentClient: Client | null\n  localRecordsContents: OrderedMap<string, Record<string, any>>\n  localRecordsChanges: List<RecordChangeRequest>\n  stagedRecordsChanges: List<RecordChangeRequest>\n  localRecordsRev: number\n  requiredAttachmentIds: Set<string>\n  clients: Map<string, Client>\n}\n\n/**\n * InstantSyncState\n *\n * Describes current state of InstantSync\n */\n\nexport default class InstantSyncState extends Immutable.Record<IInstantSyncState>({\n  requestInfo: null,\n  status: 'offline',\n  currentClient: null,\n  localRecordsContents: OrderedMap(),\n  localRecordsChanges: List(),\n  stagedRecordsChanges: List(),\n  localRecordsRev: 0,\n  requiredAttachmentIds: Set(),\n  clients: Map(),\n}) {\n  /**\n   * Holds the endpoint URL (serverURL) and authentication token to make requests.\n   */\n  override requestInfo: {\n    serverURL: string\n    authPayload: InstantSyncAuthPayload\n  }\n\n  /**\n   * Indication of whether the client is connected to the server or not. Can either be 'offline',\n   * 'connecting' or 'online'.\n   */\n  override status: 'offline' | 'connecting' | 'online'\n  override currentClient: Client\n\n  /**\n   * Holds a map of serialized object contents, which are in sync with the server and have no conflicts\n   */\n  override localRecordsContents: OrderedMap<string, Record<string, any>>\n\n  /**\n   * Holds a list for changes that have been made locally and have not yet been saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override localRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds a list for changes that have been made locally and are currently being saved on the server.\n   * For every change request (create, update, delete), we will create a new `RecordChangeRequest`\n   * object. This requires us to map every change request to the individual change set and makes\n   * it possible to support changing multiple records at once.\n   */\n  override stagedRecordsChanges: List<RecordChangeRequest>\n\n  /**\n   * Holds the latest revision of the `localRecordsContents`.\n   */\n  override localRecordsRev: number\n\n  /**\n   * All attachments ids, that need to be attached to the next request.\n   */\n  override requiredAttachmentIds: Set<string>\n\n  /**\n   * A list of all connect clients of every user that is currently present in the record.\n   */\n  override clients: Map<string, Client>\n}\n","import { Class } from 'utility-types'\nimport { List } from 'immutable'\nimport { mergeChanges } from './utils'\nimport { PSPDFKitError } from '@pspdfkit/shared'\nimport RecordChangeRequest from './RecordChangeRequest'\nimport InstantSyncCycle from './InstantSyncCycle'\nimport InstantSyncState from './InstantSyncState'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type { InstantSyncResponseChanges } from './InstantSyncCycle'\nimport type { IRecord } from './InstantProvider'\nimport { DEFAULT_LONG_POLLING_TIMEOUT } from './InstantSyncCycle'\nimport { debounceAsync } from '@/utils/debounce'\n\nexport default class InstantSync {\n  /************************\n   * Record operations\n   ************************/\n  getRecords(): List<IRecord> {\n    this._shouldFireRecordsUpdateCallback = true\n\n    return this._state.localRecordsContents\n      .map((record, id) => {\n        const { content, permissions, group } = record\n\n        return {\n          content,\n          permissions,\n          group,\n          id,\n        }\n      })\n      .toList()\n  }\n\n  createRecord(\n    id: string,\n    content: Record<string, any>,\n    attachments: Record<string, Blob>,\n    group?: string,\n  ): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        attachments,\n        group,\n        type: 'created',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  updateRecord(\n    id: string,\n    content?: Record<string, any>,\n    group?: string,\n  ): Promise<Record<string, any>> {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        content,\n        group,\n        type: 'updated',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  deleteRecord(id: string): Promise<boolean> {\n    return new Promise((resolve, reject) => {\n      if (!this.isKnownRecordId(id)) {\n        return reject(new PSPDFKitError(`Record with ID: ${id} not found.`))\n      }\n\n      const change = new RecordChangeRequest({\n        id,\n        type: 'deleted',\n        // @ts-expect-error\n        resolve,\n        reject,\n      })\n\n      this.enqueueChangeRequest(change)\n    })\n  }\n\n  onRecordsUpdates(\n    recordsUpdateCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n    acceptedRecordsCallback: (\n      created: List<Record<string, any>>,\n      updated: List<Record<string, any>>,\n      deleted: List<string>,\n    ) => void,\n  ) {\n    if (typeof recordsUpdateCallback !== 'function') {\n      throw new TypeError('recordsUpdateCallback must be a function')\n    }\n\n    if (typeof acceptedRecordsCallback !== 'function') {\n      throw new TypeError('acceptedRecordsCallback must be a function')\n    }\n\n    this._recordsUpdatesCallback = recordsUpdateCallback\n    this._acceptedRecordsResponseCallback = acceptedRecordsCallback\n  }\n\n  destroy() {\n    if (this._cycle) {\n      this._cycle.destroy()\n    }\n  }\n\n  /**************************\n   * Private Implementation *\n   **************************/\n  _state: InstantSyncState\n  _cycle: InstantSyncCycle\n  _CycleClass: Class<InstantSyncCycle>\n  _recordsUpdatesCallback: (\n    created: List<Record<string, any>>,\n    updated: List<Record<string, any>>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _acceptedRecordsResponseCallback: (\n    created: List<Record<string, any>>,\n    updated: List<Record<string, any>>,\n    deleted: List<string>,\n  ) => void = () => {}\n  _shouldFireRecordsUpdateCallback = false\n\n  /**\n   * For easier testing, we allow a custom state and Cycle class in the constructor.\n   */\n  constructor(\n    state: InstantSyncState = new InstantSyncState(),\n    CycleClass: Class<InstantSyncCycle> = InstantSyncCycle,\n  ) {\n    this._state = state\n    this._CycleClass = CycleClass\n  }\n\n  /**\n   * This method should be called right after the constructor. See {@link InstantSync.load} for the\n   * public abstraction.\n   */\n  load(\n    serverURL: string,\n    authPayload: InstantSyncAuthPayload,\n    listenToServerChangesEnabled = true,\n  ): Promise<InstantSync> {\n    return new Promise((resolve, reject) => {\n      const getState = () => this._state\n\n      const setState = this.setState.bind(this)\n\n      this.setState(\n        this._state.set('requestInfo', {\n          serverURL,\n          authPayload,\n        }),\n      )\n      this._cycle = new this._CycleClass({\n        getState,\n        setState,\n        onChanges: this.onChanges,\n        onAcceptedRecords: this.onAcceptedRecords,\n        longPollingTimeout: listenToServerChangesEnabled ? DEFAULT_LONG_POLLING_TIMEOUT : 0,\n      })\n\n      // Executing the runCycle here also means that we will do the initial synchronization\n      // with the server and fetch the records.\n      this._cycle // We force a timeout of `0` here since we don't want the initial loading to have a delay\n        .nextCycle(0)\n        .then(() => {\n          resolve(this)\n        })\n        .catch(reject)\n    })\n  }\n\n  setState(newState: InstantSyncState): void {\n    this._state = newState\n  }\n\n  onChanges = (changes: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = changes\n\n      this._recordsUpdatesCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  onAcceptedRecords = (accepted: InstantSyncResponseChanges): void => {\n    if (this._shouldFireRecordsUpdateCallback) {\n      const { created, updated, deleted } = accepted\n\n      this._acceptedRecordsResponseCallback(List(created), List(updated), List(deleted))\n    }\n  }\n  setOnDocumentHandleConflictCallback = (callback: () => void): void => {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function')\n    }\n\n    this._cycle.setOnDocumentHandleConflictCallback(callback)\n  }\n\n  enqueueChangeRequest(changeRequest: RecordChangeRequest): void {\n    const mergedRecordsChanges = mergeChanges({\n      oldChanges: this._state.localRecordsChanges,\n      newChanges: List([changeRequest]),\n    })\n\n    this.setState(this._state.set('localRecordsChanges', mergedRecordsChanges))\n  }\n\n  /**\n   * Performs next sync cycle, pushing `localRecordsChanges` and pulling remote changes.\n   */\n  syncChanges: () => Promise<void> = debounceAsync(() => this._cycle.nextCycle())\n\n  isKnownRecordId(id: string): boolean {\n    function createdChangeWithSameId(change: RecordChangeRequest): boolean {\n      return change.type === 'created' && change.id === id\n    }\n\n    const isSyncedRecord = this._state.localRecordsContents.has(id)\n\n    const isLocalRecord = !!this._state.localRecordsChanges.find(createdChangeWithSameId)\n    const isStagedRecord = !!this._state.stagedRecordsChanges.find(createdChangeWithSameId)\n\n    return isSyncedRecord || isLocalRecord || isStagedRecord\n  }\n}\n","import { Annotation, Comment, FormField } from '../../models'\nimport type { State } from '../../models'\nimport type { IRecord } from './InstantProvider'\n\nexport function getRecordInState(\n  state: State,\n  record: IRecord,\n): Annotation | Comment | FormField | string | undefined {\n  const existingAnnotations = state.get('annotations')\n  const existingFormFields = state.get('formFields')\n  const existingComments = state.get('comments')\n  const existingFormFieldValues = state.get('formattedFormFieldValues')\n  let formFieldName\n\n  if (record.id.startsWith('form-field-value/')) {\n    formFieldName = record.id.split('/')[1]\n  }\n\n  return (\n    existingAnnotations.get(record.id) ||\n    existingFormFields.find(value => value.id === record.id) ||\n    existingComments.get(record.id) ||\n    (formFieldName ? existingFormFieldValues.get(formFieldName) : undefined)\n  )\n}\n\nexport function isRecordInState(state: State, record: IRecord): boolean {\n  return Boolean(getRecordInState(state, record))\n}\n","import { List, Map, Set } from 'immutable'\nimport { error, warn, PSPDFKitError, info, invariant } from '@pspdfkit/shared'\nimport {\n  deserializeAnnotation,\n  deserializeFormFieldValue,\n  isBookmarkJSON,\n  isFormFieldJSON,\n  isFormFieldValueJSON,\n  serializeAnnotation,\n  attachmentsToObject,\n  serializeFormFieldValue,\n  serializeFormField,\n  deserializeFormField,\n  serializeComment,\n  isCommentJSON,\n  deserializeComment,\n  isSignatureInfoJSON,\n  isEmbeddedFileJSON,\n} from '../serializers/utils'\nimport {\n  toJSON as serializeBookmark,\n  fromJSON as deserializeBookmark,\n} from '../serializers/BookmarkSerializer'\nimport { CREATE_REASON_LOAD, CREATE_REASON_NEW } from '../Provider'\nimport ClientsPresence from '../ClientsPresence/ClientsPresence'\nimport InstantSync from './InstantSync'\nimport { defaultInstantSettings } from '@/models/InstantSettings'\nimport { getFormFieldValueID } from '@/models/form-fields/FormFieldValue'\nimport { isRecordInState } from './collaboration-permissions'\nimport Annotation from '@/models/annotations/Annotation'\nimport Comment from '@/models/comments/Comment'\nimport FormField from '@/models/form-fields/FormField'\nimport { getRecordInState } from './collaboration-permissions'\nimport {\n  getCollaborationPermissionsFromJSON,\n  validateCollaborationPermissionJSON,\n} from '../serializers/collaboration-permissions'\nimport { shouldShowSignatureFields } from '@/utils/permissions'\nimport { SignatureFormField } from '@/models/form-fields'\nimport { WidgetAnnotation } from '@/models'\n\nimport type { ReadStateProvider, ReadStateProviderCallbacks } from '../ReadStateProvider'\nimport type { AnnotationProvider, AnnotationProviderCallbacks } from '../AnnotationProvider'\nimport type { CreateReason } from '../Provider'\nimport type { Attachment, Bookmark } from '@/models'\nimport type { BookmarkProvider, BookmarkProviderCallbacks } from '../BookmarkProvider'\nimport type { FormFieldValue } from '@/models/form-fields'\nimport type { FormFieldProvider, FormFieldProviderCallbacks } from '../FormFieldProvider'\nimport type { FormFieldValueProvider, FormFieldValueCallbacks } from '../FormFieldValueProvider'\nimport type { ID as AnnotationID } from '@/models/annotations/Annotation'\nimport type { ID as BookmarkID } from '@/models/Bookmark'\nimport type { ID as CommentID } from '@/models/comments/Comment'\nimport type { InstantSyncAuthPayload } from './InstantSyncState'\nimport type Client from '../ClientsPresence/models/Client'\nimport type { InstantID } from '@/models/InstantID'\nimport type { CommentProvider, CommentProviderCallbacks } from '../CommentProvider'\nimport type { InstantSettings } from '@/models/InstantSettings'\nimport type { State } from '@/models'\nimport type { ISignatureFeatureAvailability } from '@/enums/SignatureFeatureAvailability'\nimport type { Class } from 'utility-types'\n\nexport type IRecord = {\n  id: string\n  content?: Record<string, any> | null\n  group?: string | null | undefined\n  permissions?: {\n    edit: boolean\n    delete: boolean\n    view: boolean\n    setGroup: boolean\n  }\n}\n\n/**\n * InstantProvider is an implementation of the AnnotationProvider that,\n * using the `/sync` endpoint, allows the client to sync with other devices and\n * benefit from server side conflict resolution.\n *\n * `createAnnotation` and `updateAnnotation` perform optimistic updates which are reverted\n * in case of conflicts with newer updates coming from the server.\n * `deleteAnnotation` instead is signed off only after the server has accepted the change\n * since in this case roll back and restore the annotation would be harder.\n */\nexport class InstantProvider\n  implements\n    ReadStateProvider,\n    AnnotationProvider,\n    BookmarkProvider,\n    FormFieldProvider,\n    FormFieldValueProvider,\n    CommentProvider\n{\n  _readStateCallbacks?: ReadStateProviderCallbacks\n  _annotationCallbacks?: AnnotationProviderCallbacks\n  _bookmarkCallbacks?: BookmarkProviderCallbacks\n  _formFieldCallbacks?: FormFieldProviderCallbacks\n  _formFieldValueCallbacks?: FormFieldValueCallbacks\n  _commentCallbacks?: CommentProviderCallbacks\n  // We keep track of the bookmarks IDs when we create new bookmarks\n  // because Instant sends a List of IDs when some deletion occurred.\n  // In such cases we can use this list to determine whether we are dealing with\n  // a bookmarks or annotation deletion.\n  _existingBookmarksIds: Set<BookmarkID> = Set()\n  _existingFormFieldsIds: Set<AnnotationID> = Set()\n  _existingFormFieldValuesIds: Set<string> = Set()\n  _existingCommentIds: Set<InstantID> = Set()\n  _sync: InstantSync\n  _clients?: ClientsPresence\n  _documentURL: string\n  _serverURL: string\n  _settings: InstantSettings\n  _authPayload: InstantSyncAuthPayload\n  _hasLoadedInitialRecords: boolean\n  _loadPromise: Promise<void> | null | undefined\n  _getState: () => State\n  _formsEnabledInConfig: boolean\n  onClientsChangeCallback: (...args: Array<any>) => any\n  _documentHandleConflictCallback: () => void = () => {}\n  _setDocumentHandleOutdatedCallback: (arg0: boolean) => void\n  _setReadStateCallbacksPromiseResolve: (() => void) | null\n  _setReadStateCallbacksPromise: Promise<void>\n  canCreateBackendOrphanWidgets = true\n\n  constructor(\n    serverURL: string,\n    documentURL: string,\n    authPayload: InstantSyncAuthPayload,\n    settings: InstantSettings = defaultInstantSettings,\n  ) {\n    this._serverURL = serverURL\n    this._documentURL = documentURL\n    this._authPayload = authPayload\n    this._settings = settings\n    this._hasLoadedInitialRecords = false\n    this._setReadStateCallbacksPromise = new Promise(resolve => {\n      this._setReadStateCallbacksPromiseResolve = resolve\n    })\n  }\n\n  load(\n    SyncClass: Class<InstantSync> = InstantSync,\n    ClientsPresenceClass: Class<ClientsPresence> = ClientsPresence,\n  ): Promise<InstantProvider> {\n    const initializationPromises: Promise<any>[] = []\n\n    // Initialize sync.\n    this._sync = new SyncClass()\n    initializationPromises.push(\n      this._sync\n        .load(\n          `${this._documentURL}/sync`,\n          this._authPayload,\n          this._settings.listenToServerChangesEnabled,\n        )\n        .catch(error),\n    )\n\n    this._sync.setOnDocumentHandleConflictCallback(this.onDocumentHandleConflict)\n\n    if (this._settings.clientsPresenceEnabled) {\n      // Initialize clients presence.\n      this._clients = new ClientsPresenceClass()\n      initializationPromises.push(\n        this._clients\n          .load(`${this._serverURL.replace(/^http/i, 'ws')}/websocket`, this._authPayload, {})\n          .then(() => {\n            const clients = this._clients\n\n            if (clients == null) return\n\n            // Register callback\n            clients.onClientUpdates(() => this._onClientsChange(clients.getClients()))\n\n            // Handle initial clients the same way as a clients updates callback\n            this._onClientsChange(clients.getClients())\n          })\n          .catch(error => {\n            warn(\n              'PSPDFKit: An error occurred while initializing the connected clients module. ' +\n                'This might be due to a lack of support for WebSockets or a related failure.\\n\\n' +\n                'Failure details:\\n\\n' +\n                error.message,\n            )\n          }),\n      )\n    }\n\n    return Promise.all(initializationPromises)\n      .then(() => {\n        return this\n      })\n      .catch(error => {\n        throw new PSPDFKitError(`Initialization of PSPDFKit Instant failed:\n${error.message}`)\n      })\n  }\n\n  destroy() {\n    if (this._sync) {\n      this._sync.destroy()\n    }\n  }\n\n  setFormsEnabledInConfig(formsEnabledInConfig: boolean) {\n    this._formsEnabledInConfig = formsEnabledInConfig\n  }\n\n  setReadStateCallbacks(readStateCallbacks: ReadStateProviderCallbacks) {\n    this._readStateCallbacks = readStateCallbacks\n\n    this._setReadStateCallbacksPromiseResolve?.()\n  }\n\n  setAnnotationCallbacks(annotationCallbacks: AnnotationProviderCallbacks) {\n    this._annotationCallbacks = annotationCallbacks\n  }\n\n  setBookmarkCallbacks(bookmarkCallbacks: BookmarkProviderCallbacks) {\n    this._bookmarkCallbacks = bookmarkCallbacks\n  }\n\n  setFormFieldCallbacks(formFieldCallbacks: FormFieldProviderCallbacks) {\n    this._formFieldCallbacks = formFieldCallbacks\n  }\n\n  setFormFieldValueCallbacks(formFieldValueCallbacks: FormFieldValueCallbacks) {\n    this._formFieldValueCallbacks = formFieldValueCallbacks\n  }\n\n  setCommentCallbacks(commentCallbacks: CommentProviderCallbacks) {\n    this._commentCallbacks = commentCallbacks\n  }\n\n  createAnnotation(annotation: Annotation, attachments: Map<string, Attachment>): Promise<void> {\n    const { id, ...data } = serializeAnnotation(annotation)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    return this._sync.createRecord(id, content, attachmentsToObject(attachments), group)\n  }\n\n  createComment(comment: Comment): Promise<void> {\n    const { id, ...data } = serializeComment(comment)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    this._existingCommentIds = this._existingCommentIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group)\n  }\n\n  async updateComment(comment: Comment): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeComment(comment))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteComment(commentId: InstantID): Promise<void> {\n    this._existingCommentIds = this._existingCommentIds.delete(commentId)\n\n    return this._sync.deleteRecord(commentId).then(() => {})\n  }\n\n  setStateGetter(getState: () => State): void {\n    this._getState = getState\n  }\n\n  async updateRecord(data: Record<string, any>): Promise<Record<string, any>> {\n    const { id, permissions, group, ...content } = data\n\n    if (\n      this._getState &&\n      this._getState() &&\n      this._getState().backend?.isCollaborationPermissionsEnabled()\n    ) {\n      return this._sync.updateRecord(\n        id,\n        permissions.edit ? content : undefined,\n        permissions.setGroup ? group : undefined,\n      )\n    } else {\n      return this._sync.updateRecord(id, content, group)\n    }\n  }\n\n  async updateAnnotation(annotation: Annotation): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeAnnotation(annotation))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteAnnotation(annotation: Annotation): Promise<void> {\n    return this._sync.deleteRecord(annotation.id).then(() => {})\n  }\n\n  createBookmark(bookmark: Bookmark): Promise<void> {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async updateBookmark(bookmark: Bookmark): Promise<void> {\n    const { id, ...content } = serializeBookmark(bookmark)\n\n    try {\n      // @ts-expect-error\n      return await this._sync.updateRecord(id, content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteBookmark(bookmarkId: BookmarkID): Promise<void> {\n    return this._sync.deleteRecord(bookmarkId).then(() => {\n      this._existingBookmarksIds = this._existingBookmarksIds.delete(bookmarkId)\n    })\n  }\n\n  createFormField(formField: FormField): Promise<void> {\n    const { id, ...data } = serializeFormField(formField)\n    // destructuring permissions to remove if from content.\n    const { group, permissions, ...content } = data\n\n    this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n\n    return this._sync.createRecord(id, content, {}, group)\n  }\n\n  async updateFormField(formField: FormField): Promise<void> {\n    try {\n      // @ts-expect-error\n      return await this.updateRecord(serializeFormField(formField))\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormField(formField: FormField): Promise<void> {\n    return this._sync.deleteRecord(formField.id).then(() => {\n      this._existingFormFieldsIds = this._existingFormFieldsIds.delete(formField.id)\n    })\n  }\n\n  // Form fields are retrieved in the annotations list\n  loadFormFields(): Promise<void> {\n    return this.loadAnnotationsForPageIndex()\n  }\n\n  createFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n    const id = getFormFieldValueID(formFieldValue)\n\n    this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n\n    return this._sync.createRecord(id, content, {})\n  }\n\n  async setFormFieldValue(formFieldValue: FormFieldValue): Promise<void> {\n    const content = serializeFormFieldValue(formFieldValue)\n\n    try {\n      // @ts-expect-error\n      return await this._sync.updateRecord(getFormFieldValueID(formFieldValue), content)\n    } catch (e) {\n      if (!(e instanceof PSPDFKitError)) {\n        throw e\n      }\n    }\n  }\n\n  deleteFormFieldValue(id: string): Promise<void> {\n    return this._sync.deleteRecord(id).then(() => {\n      this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n    })\n  }\n\n  loadAnnotationsForPageIndex(): Promise<void> {\n    // We only ever start listening to real time changes and emit events when\n    // the first page loading was initiated. This will make the behavior of the\n    // Instant annotation provider similar to what we do on the others (where we\n    // do not pre-download all annotations). This is necessary because we might\n    // not handle some callbacks before that.\n    //\n    // This also has impact on JavaScript support. We now load form fields the\n    // same way as annotations when the form designer feature is present which\n    // means form fields will not be present until the first pages have been\n    // loaded. JavaScript however might interpret document level scripts before\n    // that which will cause warnings when form fields are not initialized. See\n    // comment in connect.js before calling applyJavaScriptActionChanges.\n    //\n    // @FIXME(philipp): We need to clean that up and find a way to avoid the\n    // push to the next macro queue.\n    if (this._loadPromise) {\n      return this._loadPromise\n    }\n\n    this._loadPromise = new Promise(resolve => setTimeout(resolve, 0)).then(() => {\n      if (!this._hasLoadedInitialRecords) {\n        // Register callback\n        this._sync.onRecordsUpdates(\n          // @ts-expect-error\n\n          (c, u, d) => this._onRecordsUpdates(c, u, d, CREATE_REASON_NEW),\n          // @ts-expect-error\n          (c, u, d) => this._onAcceptedRecords(c, u, d),\n        )\n\n        // Handle initial annotations list the same way as an annotations updates callback\n        this._onRecordsUpdates(this._sync.getRecords(), List(), List(), CREATE_REASON_LOAD)\n\n        this._hasLoadedInitialRecords = true\n      }\n    })\n\n    return this._loadPromise\n  }\n\n  async loadBookmarks(): Promise<void> {\n    return\n  }\n\n  syncChanges(): Promise<void> {\n    return this._sync.syncChanges()\n  }\n\n  /**\n   * In a situation where the user has set `disableForms: true` in the configuration,\n   * we don't set `this._formFieldCallbacks` and `this._formsEnabledInConfig` is set to `false` but the server doesn't know that and keeps\n   * sending the record updates for widgets. In that case we need to filter and remove\n   * the record that are widgets if `this.__formsEnabledInConfig` is set to `false`.\n   * @param records\n   * @private\n   */\n  _filterRecords(records: List<IRecord>): List<IRecord> {\n    // @ts-expect-error\n    return records.filter(({ content }) => this._formsEnabledInConfig || !isFormFieldJSON(content))\n  }\n\n  /******************************\n   * Internal Callback Handlers *\n   ******************************/\n  _onRecordsUpdates(\n    created: List<IRecord>,\n    updated: List<IRecord>,\n    deleted: List<string>,\n    createReason: CreateReason,\n  ) {\n    let mutableBookmarkAdditions: List<Bookmark> = List()\n    const mutableFormFieldAdditions: Array<FormField> = []\n    let mutableFormFieldValueAdditions: List<FormFieldValue> = List()\n    let mutableCommentAdditions: List<Comment> = List()\n    let deletions = Set() // we also remove updated annotations that encountered an error during deserializing\n\n    let bookmarkDeletions = Set() // we also remove updated bookmarks that encountered an error during deserializing\n\n    let formFieldDeletions = Set() // we also remove updated form fields that encountered an error during deserializing\n\n    let formFieldValueDeletions = Set() // we also remove updated form field values that encountered an error during deserializing\n\n    let commentDeletions = Set()\n    const state = this._getState ? this._getState() : undefined\n    let _created = created\n    let _updated = updated\n    let _deleted = deleted\n\n    if (state && state.backend && state.backend.isCollaborationPermissionsEnabled()) {\n      _created = _created.filter(({ content }) => !!content)\n\n      const updatesIndexToBeRemoved: number[] = []\n\n      updated.forEach((record, index) => {\n        if (!record.content) {\n          if (isRecordInState(state, record)) {\n            // If we receive a record with no content and it’s present in our store,\n            // it means it’s visibility permission was set to hidden and\n            // we delete the record from our store.\n            _deleted = _deleted.push(record.id)\n            updatesIndexToBeRemoved.push(index)\n          } else {\n            // If we receive a record with no content and it’s not present in our store, we do nothing.\n            updatesIndexToBeRemoved.push(index)\n          }\n        } else if (!isRecordInState(state, record)) {\n          // If we receive a record with content which isn’t present in our store, it means the visibility permission was changed.\n          // In that case, we will create a new record.\n          _created = _created.push(record)\n          updatesIndexToBeRemoved.push(index)\n        }\n      })\n      _updated = _updated.filter((_record, index) => !updatesIndexToBeRemoved.includes(index))\n      _deleted = _deleted.filter(\n        d =>\n          state.annotations.has(d) ||\n          this._existingFormFieldValuesIds.has(d) ||\n          this._existingFormFieldsIds.has(d) ||\n          this._existingCommentIds.has(d) ||\n          this._existingBookmarksIds.has(d),\n      )\n    }\n\n    let additions = List().withMutations(mutableAdditions => {\n      this._filterRecords(_created).forEach(({ id, content, permissions, group }) => {\n        const options = {\n          permissions,\n          group,\n        }\n\n        try {\n          // @ts-expect-error\n          if (isFormFieldJSON(content)) {\n            // @ts-expect-error\n            mutableFormFieldAdditions.push(deserializeFormField(id, content, options))\n            this._existingFormFieldsIds = this._existingFormFieldsIds.add(id)\n            // @ts-expect-error\n          } else if (isFormFieldValueJSON(content)) {\n            mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.push(\n              // @ts-expect-error\n              deserializeFormFieldValue(content),\n            )\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.add(id)\n            // @ts-expect-error\n          } else if (isBookmarkJSON(content)) {\n            // TODO figure out why when I use mutableBookmarkAdditions asMutable() push produces a list of IDs only 🤷‍♂️\n            mutableBookmarkAdditions = mutableBookmarkAdditions.push(\n              // @ts-expect-error\n              deserializeBookmark(id, content),\n            )\n            this._existingBookmarksIds = this._existingBookmarksIds.add(id)\n            // @ts-expect-error\n          } else if (isCommentJSON(content)) {\n            this._existingCommentIds = this._existingCommentIds.add(id)\n            mutableCommentAdditions = mutableCommentAdditions.push(\n              // @ts-expect-error\n              deserializeComment(id, content, options),\n            )\n            // @ts-expect-error\n          } else if (isSignatureInfoJSON(content)) {\n            // No-op on digital signatures changes since we won't be syncing signatures\n            // on real-time\n            // @ts-expect-error\n          } else if (isEmbeddedFileJSON(content)) {\n            // No-op since web does not support embedded files yet.\n          } else {\n            // @ts-expect-error\n            mutableAdditions.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          info(\n            `Skipped creating record #${id} from payload because an error occurred while deserializing.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n    const showSignatures = state\n      ? shouldShowSignatureFields(\n          state.features,\n          state.signatureFeatureAvailability as ISignatureFeatureAvailability,\n        )\n      : true\n\n    if (mutableFormFieldAdditions.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      if (state && !showSignatures) {\n        // Although Server returns all form fields, if the needed license features\n        // combination is not given, we should avoid to add signature form fields.\n        // See https://docs.google.com/document/d/1ry0uJIGAgUPa6cmjCWCKRC5zReqdfpROuQyhOt7GXNs/edit#heading=h.dlbwh9b87wv3\n        this._formFieldCallbacks.createFormFields(\n          List(\n            mutableFormFieldAdditions.filter(\n              formField => !(formField instanceof SignatureFormField),\n            ),\n          ),\n          createReason,\n        )\n      } else {\n        this._formFieldCallbacks.createFormFields(List(mutableFormFieldAdditions), createReason)\n      }\n    }\n\n    if (additions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      if (state && !showSignatures) {\n        // Don't store widgets associated to ignored form fields on step above\n        additions = additions.filter(annotation => {\n          if (!(annotation instanceof WidgetAnnotation)) {\n            return annotation\n          }\n\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === annotation.formFieldName) ||\n            state.formFields.get(annotation.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._annotationCallbacks.createAnnotations(additions, Map(), createReason)\n    }\n\n    if (mutableFormFieldValueAdditions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      if (state && !showSignatures) {\n        // Take into account purposefully ignored form fields from step above\n        mutableFormFieldValueAdditions = mutableFormFieldValueAdditions.filter(value => {\n          const formField =\n            mutableFormFieldAdditions.find(field => field.name === value.name) ||\n            // @ts-expect-error\n            state.formFields.get(value.formFieldName)\n\n          return !(formField && formField instanceof SignatureFormField)\n        })\n      }\n\n      this._formFieldValueCallbacks.createFormFieldValues(\n        List(mutableFormFieldValueAdditions),\n        createReason,\n      )\n    }\n\n    if (mutableCommentAdditions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.createComments(mutableCommentAdditions, createReason)\n    }\n\n    if (mutableBookmarkAdditions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.createBookmarks(mutableBookmarkAdditions, createReason)\n    }\n\n    const mutableBookmarkChanges: List<Bookmark> = List().asMutable()\n    const mutableFormFieldChanges: Array<FormField> = []\n    const mutableFormFieldValueChanges: Array<FormFieldValue> = []\n    const mutableCommentChanges: Array<Comment> = []\n    const updates = List().withMutations(mutableUpdates => {\n      this._filterRecords(_updated).forEach(({ id, content, group, permissions }) => {\n        const options = {\n          permissions,\n          group,\n        }\n\n        try {\n          // @ts-expect-error\n          if (isFormFieldJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableFormFieldChanges.push(deserializeFormField(id, content, options))\n            } catch (error) {\n              formFieldDeletions = formFieldDeletions.add(id)\n              info(\n                `Skipped updating form field #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isFormFieldValueJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableFormFieldValueChanges.push(deserializeFormFieldValue(content))\n            } catch (error) {\n              formFieldValueDeletions = formFieldValueDeletions.add(id)\n              info(\n                `Skipped updating form field value #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isBookmarkJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableBookmarkChanges.push(deserializeBookmark(id, content))\n            } catch (error) {\n              bookmarkDeletions = bookmarkDeletions.add(id)\n              info(\n                `Skipped updating bookmark #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n              )\n              info(error)\n            }\n            // @ts-expect-error\n          } else if (isCommentJSON(content)) {\n            try {\n              // @ts-expect-error\n              mutableCommentChanges.push(deserializeComment(id, content, options))\n            } catch (error) {\n              commentDeletions = commentDeletions.add(id)\n              info(\n                `Skipped updating comment #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n                // @ts-expect-error\n                content,\n                error,\n              )\n            }\n          } else {\n            // @ts-expect-error\n            mutableUpdates.push(deserializeAnnotation(id, content, options))\n          }\n        } catch (error) {\n          deletions = deletions.add(id)\n          info(\n            `Skipped updating annotation #${id} from payload because an error occurred while deserializing. To avoid issues, we have removed the previous version from the application state.`,\n            // @ts-expect-error\n            content,\n          )\n          info(error)\n        }\n      })\n    })\n\n    if (updates.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.updateAnnotations(updates)\n    }\n\n    if (mutableBookmarkChanges.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.updateBookmarks(mutableBookmarkChanges)\n    }\n\n    if (mutableFormFieldChanges.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(mutableFormFieldChanges))\n    }\n\n    if (mutableFormFieldValueChanges.length > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.setFormFieldValues(List(mutableFormFieldValueChanges))\n    }\n\n    if (mutableCommentChanges.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(mutableCommentChanges))\n    }\n\n    deletions = deletions.concat(\n      _deleted\n        .filter(\n          id =>\n            !this._existingBookmarksIds.has(id) &&\n            !this._existingFormFieldsIds.has(id) &&\n            !this._existingFormFieldValuesIds.has(id) &&\n            !this._existingCommentIds.has(id),\n        )\n        .toSet(),\n    )\n\n    if (deletions.size > 0) {\n      invariant(this._annotationCallbacks)\n\n      this._annotationCallbacks.deleteAnnotations(deletions)\n    }\n\n    bookmarkDeletions = bookmarkDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isBookmarkDeletion = this._existingBookmarksIds.has(id)\n\n          if (isBookmarkDeletion) {\n            this._existingBookmarksIds = this._existingBookmarksIds.delete(id)\n          }\n\n          return isBookmarkDeletion\n        })\n        .toSet(),\n    )\n\n    if (bookmarkDeletions.size > 0) {\n      invariant(this._bookmarkCallbacks)\n\n      this._bookmarkCallbacks.deleteBookmarks(bookmarkDeletions)\n    }\n\n    formFieldDeletions = formFieldDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldDeletion = this._existingFormFieldsIds.has(id)\n\n          if (isFormFieldDeletion) {\n            this._existingFormFieldsIds = this._existingFormFieldsIds.delete(id)\n          }\n\n          return isFormFieldDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldDeletions.size > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(formFieldDeletions)\n    }\n\n    formFieldValueDeletions = formFieldValueDeletions.concat(\n      _deleted\n        .filter(id => {\n          const isFormFieldValueDeletion = this._existingFormFieldValuesIds.has(id)\n\n          if (isFormFieldValueDeletion) {\n            this._existingFormFieldValuesIds = this._existingFormFieldValuesIds.delete(id)\n          }\n\n          return isFormFieldValueDeletion\n        })\n        .toSet(),\n    )\n\n    if (formFieldValueDeletions.size > 0) {\n      invariant(this._formFieldValueCallbacks)\n\n      this._formFieldValueCallbacks.deleteFormFieldValues(formFieldValueDeletions)\n    }\n\n    commentDeletions = commentDeletions.concat(\n      _deleted\n        .filter(id => {\n          const commentDeletion = this._existingCommentIds.has(id)\n\n          if (commentDeletion) {\n            this._existingCommentIds = this._existingCommentIds.delete(id)\n          }\n\n          return commentDeletion\n        })\n        .toSet(),\n    )\n\n    if (commentDeletions.size > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(commentDeletions)\n    }\n  }\n\n  _onAcceptedRecords(created: List<IRecord>, updated: List<IRecord>) {\n    const state = this._getState ? this._getState() : undefined\n\n    if (!state || !state.backend || !state.backend.isCollaborationPermissionsEnabled()) {\n      return\n    }\n\n    // When Collaboration Permissions are enabled we need to update the locally created or updated\n    // records so that they include the proper permissions enforced by the backend.\n    const annotationsUpdates: Array<Annotation> = []\n    const commentsUpdates: Array<Comment> = []\n    const formFieldsUpdates: Array<FormField> = []\n    // We also need to remove records from the Redux store if Server doesn't assign view\n    // permissions\n    const deletableAnnotations: Array<AnnotationID> = []\n    const deletableComments: Array<BookmarkID> = []\n    const deletableFormFields: Array<CommentID> = []\n\n    if (!created.isEmpty()) {\n      created.forEach(mergePermissionsOnRecords)\n    }\n\n    if (!updated.isEmpty()) {\n      updated.forEach(mergePermissionsOnRecords)\n    }\n\n    if (annotationsUpdates.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.updateAnnotations(List(annotationsUpdates), true)\n    }\n\n    if (commentsUpdates.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.updateComments(List(commentsUpdates))\n    }\n\n    if (formFieldsUpdates.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.updateFormFields(List(formFieldsUpdates))\n    }\n\n    if (deletableAnnotations.length > 0) {\n      invariant(this._annotationCallbacks)\n\n      // @ts-expect-error\n      this._annotationCallbacks.deleteAnnotations(Set(deletableAnnotations), true)\n    }\n\n    if (deletableComments.length > 0) {\n      invariant(this._commentCallbacks)\n\n      this._commentCallbacks.deleteComments(Set(deletableComments))\n    }\n\n    if (deletableFormFields.length > 0) {\n      invariant(this._formFieldCallbacks)\n\n      this._formFieldCallbacks.deleteFormFields(Set(deletableFormFields))\n    }\n\n    function mergePermissionsOnRecords(record: IRecord) {\n      const options = {\n        permissions: record.permissions,\n        group: record.group,\n      }\n      let entity = getRecordInState(state as State, record)\n\n      // We can ignore form field values responses (string type)\n      if (entity && typeof entity !== 'string') {\n        validateCollaborationPermissionJSON(options)\n\n        const collaborationPermissions = getCollaborationPermissionsFromJSON(options)\n\n        entity = entity.merge(collaborationPermissions)\n\n        if (entity instanceof Annotation) {\n          if (options.permissions && options.permissions.view) {\n            annotationsUpdates.push(entity)\n          } else {\n            deletableAnnotations.push(entity.id)\n          }\n        } else if (entity instanceof Comment) {\n          if (options.permissions && options.permissions.view) {\n            commentsUpdates.push(entity)\n          } else {\n            invariant(entity.id)\n            deletableComments.push(entity.id)\n          }\n        } else if (entity instanceof FormField) {\n          if (options.permissions && options.permissions.view) {\n            formFieldsUpdates.push(entity)\n          } else {\n            deletableFormFields.push(entity.id)\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * Sets the on clients change callback. Will be overwritten when another callback is set.\n   */\n  onClientsChange(onClientsChangeCallback: (clients: Map<string, Client>) => void): void {\n    if (typeof onClientsChangeCallback !== 'function') {\n      throw new TypeError('Callback must be a function')\n    }\n\n    this.onClientsChangeCallback = onClientsChangeCallback\n  }\n\n  _onClientsChange(clients: Map<string, Client>): void {\n    this.onClientsChangeCallback.call(null, clients)\n  }\n\n  /**\n   * Document handle conflict callback handlers.\n   */\n\n  /**\n   * Set by ServerBackend after instantiating the provider\n   */\n  setDocumentHandleConflictCallback = (callback: () => void) => {\n    this._documentHandleConflictCallback = callback\n  }\n\n  /**\n   * Set in utils/document by setupManagers() on connect and reconnect\n   */\n  setDocumentHandleOutdated = (callback: (arg0: boolean) => void) => {\n    this._setDocumentHandleOutdatedCallback = callback\n  }\n\n  /**\n   * Callback passed to InstantSync when instantiating it\n   */\n  onDocumentHandleConflict = () => {\n    this._documentHandleConflictCallback && this._documentHandleConflictCallback()\n    this._setDocumentHandleOutdatedCallback && this._setDocumentHandleOutdatedCallback(true)\n  }\n}\n"],"names":["Client","Immutable","clientId","userId","presenceContent","ClientsPresenceState","status","currentClient","clients","Map","Timer","constructor","callback","timerCalc","this","timer","tries","reset","clearTimeout","scheduleTimeout","setTimeout","CLIENT_VERSION","SOCKET_STATES","CLIENT_INFO","name","defaultReconnectTimerCalc","n","WebsocketConnection","serverURL","authPayload","reconnectTimerCalc","enableReconnect","events","eventEmitter","EventEmitter","concat","socket","lastRequestId","requestsWaitingForAnswers","reconnectTimer","close","connect","clearAuthenticationInformation","registerEvents","push","WebSocket","onopen","onOpen","bind","onmessage","onMessage","onerror","emit","disconnect","onclose","abortOpenRequests","connectionState","readyState","isAuthenticated","sendRequest","action","payload","Promise","resolve","reject","PSPDFKitError","requestId","nextRequestId","serializedPayload","JSON","stringify","set","send","on","off","onError","onClose","message","data","frame","parseFrame","invariant","has","request","get","reason","delete","includes","log","parseUnauthenticatedFrame","onHello","onAuthenticated","event","error","protocol_version","requestPayload","client_version","client_info","auth_payload","client_id","user_id","getEnvironment","args","console","requestIdOrInfo","exec","toString","parseInt","parse","forEach","clientFromPayload","presence","ClientsPresence","state","connectionClass","load","initialPresenceContent","setState","newState","connection","session","populateClients","then","catch","onInfoClientPresence","withMutations","mutableState","map","clientPayload","c","setClientsAction","newClients","mutableClients","entered","client","updated","left","applyClientChangesAction","shouldFireClientUpdatesCallback","enteredClientIds","filter","indexOf","toMap","updatedClientIds","List","clientUpdatesCallback","getStatus","getCurrentClient","getClients","updatePresence","setIn","updateCurrentClientPresenceAction","onClientUpdates","TypeError","RecordChangeRequest","content","attachments","id","type","group","undefined","InstantSyncState","requestInfo","localRecordsContents","OrderedMap","localRecordsChanges","stagedRecordsChanges","localRecordsRev","requiredAttachmentIds","Set","InstantSync","getRecords","_shouldFireRecordsUpdateCallback","_state","record","permissions","toList","createRecord","change","enqueueChangeRequest","updateRecord","isKnownRecordId","deleteRecord","onRecordsUpdates","recordsUpdateCallback","acceptedRecordsCallback","_recordsUpdatesCallback","_acceptedRecordsResponseCallback","destroy","_cycle","CycleClass","InstantSyncCycle","_CycleClass","listenToServerChangesEnabled","getState","onChanges","onAcceptedRecords","longPollingTimeout","DEFAULT_LONG_POLLING_TIMEOUT","nextCycle","changes","created","deleted","accepted","setOnDocumentHandleConflictCallback","changeRequest","mergedRecordsChanges","mergeChanges","oldChanges","newChanges","syncChanges","debounceAsync","createdChangeWithSameId","isSyncedRecord","isLocalRecord","find","isStagedRecord","getRecordInState","existingAnnotations","existingFormFields","existingComments","existingFormFieldValues","formFieldName","startsWith","split","value","isRecordInState","Boolean","InstantProvider","_existingBookmarksIds","_existingFormFieldsIds","_existingFormFieldValuesIds","_existingCommentIds","_documentHandleConflictCallback","canCreateBackendOrphanWidgets","documentURL","settings","defaultInstantSettings","_serverURL","_documentURL","_authPayload","_settings","_hasLoadedInitialRecords","_setReadStateCallbacksPromise","_setReadStateCallbacksPromiseResolve","SyncClass","ClientsPresenceClass","initializationPromises","_sync","onDocumentHandleConflict","clientsPresenceEnabled","_clients","replace","_onClientsChange","warn","all","setFormsEnabledInConfig","formsEnabledInConfig","_formsEnabledInConfig","setReadStateCallbacks","readStateCallbacks","_readStateCallbacks","setAnnotationCallbacks","annotationCallbacks","_annotationCallbacks","setBookmarkCallbacks","bookmarkCallbacks","_bookmarkCallbacks","setFormFieldCallbacks","formFieldCallbacks","_formFieldCallbacks","setFormFieldValueCallbacks","formFieldValueCallbacks","_formFieldValueCallbacks","setCommentCallbacks","commentCallbacks","_commentCallbacks","createAnnotation","annotation","serializeAnnotation","attachmentsToObject","createComment","comment","serializeComment","add","e","deleteComment","commentId","setStateGetter","_getState","backend","isCollaborationPermissionsEnabled","edit","setGroup","deleteAnnotation","createBookmark","bookmark","serializeBookmark","deleteBookmark","bookmarkId","createFormField","formField","serializeFormField","deleteFormField","loadFormFields","loadAnnotationsForPageIndex","createFormFieldValue","formFieldValue","serializeFormFieldValue","getFormFieldValueID","deleteFormFieldValue","_loadPromise","u","d","_onRecordsUpdates","CREATE_REASON_NEW","_onAcceptedRecords","CREATE_REASON_LOAD","_filterRecords","records","isFormFieldJSON","createReason","mutableBookmarkAdditions","mutableFormFieldAdditions","mutableFormFieldValueAdditions","mutableCommentAdditions","deletions","bookmarkDeletions","formFieldDeletions","formFieldValueDeletions","commentDeletions","_created","_updated","_deleted","updatesIndexToBeRemoved","index","_record","annotations","additions","mutableAdditions","options","deserializeFormField","isFormFieldValueJSON","deserializeFormFieldValue","isBookmarkJSON","deserializeBookmark","isCommentJSON","deserializeComment","isSignatureInfoJSON","isEmbeddedFileJSON","deserializeAnnotation","info","showSignatures","shouldShowSignatureFields","features","signatureFeatureAvailability","length","createFormFields","SignatureFormField","size","WidgetAnnotation","field","formFields","createAnnotations","createFormFieldValues","createComments","createBookmarks","mutableBookmarkChanges","asMutable","mutableFormFieldChanges","mutableFormFieldValueChanges","mutableCommentChanges","updates","mutableUpdates","updateAnnotations","updateBookmarks","updateFormFields","setFormFieldValues","updateComments","toSet","deleteAnnotations","isBookmarkDeletion","deleteBookmarks","isFormFieldDeletion","deleteFormFields","isFormFieldValueDeletion","deleteFormFieldValues","commentDeletion","deleteComments","annotationsUpdates","commentsUpdates","formFieldsUpdates","deletableAnnotations","deletableComments","deletableFormFields","mergePermissionsOnRecords","entity","validateCollaborationPermissionJSON","collaborationPermissions","getCollaborationPermissionsFromJSON","merge","Annotation","view","Comment","FormField","isEmpty","onClientsChange","onClientsChangeCallback","call","setDocumentHandleConflictCallback","setDocumentHandleOutdated","_setDocumentHandleOutdatedCallback"],"sourceRoot":""}